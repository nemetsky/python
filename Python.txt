### НЕОБХОДИМО ПОСТАВИТЬ МОДУЛИ ###
pip install pytest pytest-clarity==0.3.0a0 pyyaml tabulate jinja1 textfsm netmiko

https://pythontutor.com/                         # Деббагер
https://replit.com/languages/python3             # Тренажер
https://docs.python.org/3.8/py-modindex.html     # Стандартная библитека модулей
https://regex101.com/                            # Тренажер регулярных выражений (флаги описаны в теме регулярки (global, single line, multiline))
https://habr.com/ru/articles/349860/             # Статья про регулярные выражения

бонусная лекция - модуль Rich
==============================================================================================

###  Типы данных: ###
Изменяемые:
 - списки (Lists)
 - словари (Dictionaries)
 - множества (Sets)
 
 Неизменяемые:
 - числа (Numbers)
 - строки (Strings)
 - кортежи (Tuples)
 
 Упорядоченные:
 - списки
 - кортежи
 - строки
 - словари
 
 Неупорядоченные:
 - множества
 
 Есть еще тип Boolean

==============================================================================================

### ЧИСЛА ###

# в python переменные это метки (ссылки)
a = 5
b = a
# то есть переменные a и b это ссылки на одно и тоже значение которое где то хранится в памяти, а не два одинаковых значения
# одинаковые id у них
id(a)
id(b)

# есть отличие от списков, так как переменные это неизменяемые типы данных, а списки изменяемые
# у переменных с одинковым значением от 1 до 254 - id переменных будут с одинаковым значением, 
# а со значением от 255 и выше у каждой переменной (если значения одинаковы, без применения ссылок), то будут разные id
# но если сделать ссылку на число то id буду одинаковым
a = 1000
b = a             # b будет 1000 и id будет одинаковые

round(10/3, 2)    # округлить до двух знаков

10%3              # остаток от деления

# операторы сравнения 
==     # равно
!=     # не равно

# Число записывается без кавычек, может быть float, Например 10.0 
data = "11"
int(data)         # преобразовать в десятичное число 11
int(data, 2)      # говорим что преобразовать из двоичного системы счисления в десятичное число, результат здесь будет 3
bin(255)          # преобразовать из десятичного в двоичное (0b будет начинаться), 0b11111111
hex(255)          # из десячного в шеснадцатиричный (0x будет начинаться), 0xff
int("0x11", 16)   # из 16-ричного значения преброзовать в десятичное, будет 17

# Сразу из 16-ричного в двоичное преобразовать нельзя, через десятичное только
h = "ff"
dec_h = int(h, 16)
bin(dec_h)
# или сразу так
bin(int(h, 16))

#
int(4.5)           # будет 4, округление до меньшего

a, b = 1, 2     # значит a = 1, b = 2  групповое создание переменных

+=    # значит к этому числу прибавить что то, например:
а = 5
а = а + 5 
# или просто
a += 5
# есть также -= ,  *=

# для сложных математических функций есть модуль math
import math

==============================================================================================

### СТРОКИ ###

Кавычки или двойные "" или одинарные '', строку исходную менять нельзя 

# экранирование символов
\'      

# многострочная строка, все скрытые символы включены будут в строку (пробелы, переводы строки)
template = """ 
  interface Tunnel0
   ip address 10.10.10.1 255.255.255.0
   ip mtu 1416
"""

# конкатинация строки 
a = "test" "hello"        # результат -> testhello

# разбить строку на литералы для удобства, а также для случаев с ограничениями на макс.число символов в строке
s = ('Test' 'String')     # TestString
s = ('Test'
'String')                 # TestString

# разбить строку в разные строки
a = ("test\n" "hello\n")

# еще важный пример разбить строку на разные строки (часто пригодится)
template = ( 
  "interface Tunnel0\n"
  " ip address 10.10.10.1 255.255.255.0\n"
  " ip mtu 1416\n"
)
# print(template) - красиво покажет вывод с переводом строк, без лишних пробелов в начале строк

# строке можно обращаться по индексу или делать срез строки
cmd = "interface Gi0/0"
cmd[2]                    # "t"
cmd[-4]                   # "i"  
cmd[0:5]                  # "inter" - последний символ не включается в срезе
cmd[2:]                   # срезать от 2 до конца
cmd[:7]                   # срезать с 0 до до 7
cmd[-7:]                  # срезать от -7 до конца

# можно в индексах использовать переменные, только числа
# срез с шагом
s = "0123456789"
s[0:9:2]                  # "02468"
s[1:9:2]                  # "1357"
s[0:9:3]                  # "036"
s[::3]                    # "0369"
s[::2]                    # "02468"
s[::-1]                   # "9876543210"  - в обратном порядке

# строки можно складывать, отличается от конкатинации, тем что сами переменные объеденяются а не их литералы
а = "hello"
b = "world"
a + b   - >  "helloworld"
print(a + " " + b)

# строку можно умножать (повторение)   !(строку с числом складывать нельзя)
"test" * 2      #  testtest

# количество символов (длина переменной), спецсимволы тоже считаются
len(cmd)        #  15

-----------------------------------------------------

### МЕТОД ###   - это фунцкия прилепленная к конкретному типу данных

cmd = "interface Gi0/0"
cmd.upper()      # "INTERFACE GI0/0"  - то есть метод upper сделал заглывные буквы у переменной cmd

cmd.lower?       # будет подсказка по методу
cmd.<TAB>        # все методы покажет

cmd.swapcase()
cmd.capitalize()

cmd.startswith("interface")    #  true     
cmd.endswith("interface")      #  false     
if cmd.startswith("interface"):
    print("OK") 

cmd.startswith(" interface", 1)          # true, проверить начало строки начиная с индекса 1 (к примеру пропустить пробел)
cmd.startswith(("test", "interface"))    # true, строка начинается или с того или с того

cmd.count("e")                           # 2 раза, посчитать сколько раз встречается подстрока      
 
cmd.find("face")                         # найти подстроку, вернет индекс с которого она начинается, если не найдет то вернет -1

index = cmd.find("face")                 # записали в переменную index индекс с которого начинается подсрока face в строке cmd
cmd[index:]                              # сделали срез в строке

cmd = " switchport mode access"
find_word = "mode"
index = cmd.find(find_word)
cmd[index:index + len(find_word)]        # получим слово "mode" сделав срез

cmd.replace("access", "trunk")                               # заменить подсроку в строке (заменяет все вхождения)
cmd.replace("o", "test", 1)                                  # заменить только первое вхождение
cmd.replace("mode", "").replace("trunk", "access vlan 2")    # удалили "mode" и паравозиком еще раз заменили подстроку)

cmd = "\n\n\tinterface Gi0/0\n\t"
cmd.strip()                       # удалить все спец. символы в начале и в конце строки
cmd.lstrip()                      # удалить все спец. символы в начале строки
cmd.rstrip()                      # удалить все спец. символы в конце строки

s = "[110/25]"
s.strip("[]")                     # 110/25 , удалили конкретные символы в конце и начале

cmd = " switchport trunk allowed vlan 1,2,3,4,5\n"
cmd.split()                       # удалить спец символы и разделить строку на отдельные элементы строки по пробелам
cmd.split()[-2]                   # "vlan" , разбить строку и взять 2-ой с конца элемент

vlan = "1,2,3,4,5"
vlan.split(",")                   # ['1', '2', '3', '4', '5']  - разделить на элементы по запятой
ip = "10.1.1.1"
ip.split(".")                     # ['10', '1', '1', '1']  - разделить на элементы по точке

-----------------------------------------------------

### ФОРМАТИРОВАНИЕ СТРОК ###   -  подстановка значений в шаблон переменной, используются скобки {}

cmd = "interface Gi0/{}"
cmd.format(10)                                  # interface Gi0/10

template = """                                  # можно и с replace заменить но это некрасиво и неправльно будет
  interface Tunnel{}
   ip address {}
   ip mtu 1416
"""
template.format(0, "10.1.1.1 255.255.255.0")    # подстановка значений по порядку

template = """                                  # можно в формате индексы проставить, если не попорядку подставлять значения, лучше так как можно одно значение несколько раз подставить
  interface Tunnel{1}
   ip address {0}
   ip mtu 1416
"""
template.format("10.1.1.1 255.255.255.0", 0)    

template = """                                  # можно в формате имена использовать, более понятно и удобнее, также можно несколько раз передавать одно и тоже значение в шаблон
  interface Tunnel{tun_num}
   ip address {ip_addr}
   ip mtu 1416
"""
template.format(ip_addr="10.1.1.1 255.255.255.0", tun_num=0)    

output = "{} {} {}\n"*2
output.format("Fa0/1", "10.1.1.1", "255.255.255.0", "Fa0/15", "10.200.1.1", "255.255.255.0")     # при отображении этих двух строк будет сдвиг

output = "{:10}{:20}{}\n"*2                     # выравнивание, задать ширину значения/столбца с запасом, тогда при отображении строк сдвига не будет
output = "{:<10}{:>20}{}\n"*2                   # выравнивание < по левой стороне, > по правой стороне

template ="{:b} {:b} {:b} {:b}"                 # конвертировать в двоичный формат
template.format(10, 1, 100, 168)
template = "{:08b} {:08b} {:08b} {:08b}"        # перевести в двоичный формат и заполнить нулями до восьми символов (08)
template = "{0:<9}{1:<9}{2:<9}{3:<9}\n{0:08b} {1:08b} {2:08b} {3:08b}"        # вывести адрес в десятичном и двоичном виде и выровнять

-----------------------------------------------------

### F-СТРОКИ ###  - форматирование строк, нет разделения между шаблоном и данными (в циклах удобнее работать)

intf = "Gi0/0"
f"interface {intf}"                   # получим "interface Gi0/0"

cmd = "switchport trunk allowed vlan"
vlan = "1,2,3,4"
f"{cmd} {vlan}"                       # получим объединение строк, также как: cmd + " " + vlan
f"{cmd.upper()} {vlan}"               # плюс также в том, что в f-строке можно использовать методы в переменной

oct1, oct2, oct3, oct4 = 10, 1, 100, 168 
template = f"{oct1:<9}{oct2:<9}{oct3:<9}{oct4:<9}\n{oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}"   # тоже самое форматирование через ф-строку (выведет в двоичном и десятичном форате Ip-адрес)

-----------------------------------------------------

### СПИСОК (list) ###

# последовательность любых элементов, разделенных запятой в квадратных скобках,  в отличие от строк это изменяемый тип данных

list1 = [10, 20, 77, "word"]          # могут быть необязательно однотипные данные в списке
list2 = [                             # для удобства красоты можно столбиком делать список
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]

vlan = "1, 2, 3, 4"
vlan.split(",")         # ["1", "2", "3", "4"]  получить список строк из строки по разделителю запятой

list("test")            # ["t", "e", "s", "t"]  функция list из строки делает список символов

vlans = [10, 100, 101, 200, 201, 202]
vlans[0]                # 10    первый элемент списка, возвращает число
vlans[3]                # 200   четвертый элемент списка
vlans[-1]               # 202   первый с конда элемент списка
vlans[1:4]              # [100, 101, 200]   сделать срез по списку, возвращает список
vlans[3:]               # [200, 201, 202] 
vlans[:4]               # [10, 100, 101, 200] 
vlans[3] = 1200         # изменить элемент под индексом 3 

# СПИСОК СПИСКОВ

vlans = [[10,20,30],[100,200,300],[1000,2000,3000]]
vlans[1]                # [100,200,300]
vlans[1][-1]            # 300

# или через промежуточную переменную
list0 = vlans[1]
list0[-1]               # 300

vlans[1][-1] = 400      # изменить элемент во вложенном списке
interfaces[0][1][1]     # можно список списков разобрать на символы

len(vlans)              # посчитать количество элементов в списке
set(vlans)              # превратит в множество и удалит дубликаты

sorted(vlans)           # сортировака списка, если есть вложенность, то сортирует списки по первому элементу списка, возвращает новый превращает в список
                        # можно по алфавиту сортировать, учитывается регистр, можно в обратном порядке сортировать
                        # числа и строки сортируются по разному, если к примеру сортируем vlan то лучше их превратить в числа предварительно
                        # строки можно сравнивать (сравнение идет по юникод коду символов по порядку)

# МЕТОДЫ РАБОТЫ СО СПИСКАМИ

# функция sorted работает с разными типами данных и возвращает новый список чисел или строк к примеру
result = sorted(vlans)
print(result)

# метод sotr работает только со списками и сортирует тот же самый список и по умолчанию результат не выводит на print (выводит NONE)
vlans.sort()            # отсортирует список но ничего не выведет (NONE)
print(vlans)            # так выведет на экран

vlans.reverse()         # сделает список наоборот

vlans.count(10)         # посчитать сколько 10 в списке
vlans.append(500)       # добавить в конец списка элемент 500, можно создать пустой список и в него добавлять: vlans = []
                        # добавить можно по одному элементу только
vlans.append([100,200]) # можно в список добавить список, но только один

# суммирование списков
vlans1 = [10,20,30,40]
vlans2 = [100,200,300]
vlans1.extend(vlans2)           # прибавить элементы списка vlans2 в список vlan1
vlans1.extend([5,55])           # тоже добавить в список

all_vlans = vlans1 + vlans2     # второй способ суммирования списков, будет новый список в отличие от extend

# метод join - разделитель, применяется для строк или списка строк (если есть список чисел, то их надо преобразовать в спиcок строк сначала)

vlans_str = ["1", "2", "3"]
"".join(vlans_str)              # '123'
",".join(vlans_str)             # '1,2,3'
" = ".join(vlans_str)           # '1 = 2 = 3'

# если есть список строк разделенных например \n, то можно преобразовать в строку с разделителями
access = [
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]
"\n".join(access)               # 'switchport mode access\nswitchport access vlan 20\nspanning-tree portfast'

print("\n".join(access))        # switchport mode access
                                # switchport access vlan 20
                                # spanning-tree portfast

# можно обратно строку в список перевести
data = "\n".join(access)
data.split("\n")

# pop - взять элемент из списка по индексу и удалить его из списка, только один элемент может удалить, элемент который удаляет можно присвоить переменной
vlans = [10,100,101,200,201,202]
vlans.pop()                     # 202   - по умолчанию удаляет последний элемент мз списка
vlans.pop(-1)                   # 201
vlans.pop(0)                    # 10

# remove удаляет значение (только одно), и ничего не возвращает (нельзя записать в переменную) (удалять несколько значений надо через циклы)
vlans.remove(100)               # удалит из списка элемент со значением 100, если есть несколько элементов, то удалит первый с таким значением

# ниже можно тоже самое сделать через pop, только одной командой
a = vlans[-1]
vlans.remove(a)

vlans.index(201)                # вернет индекс под которым этот элемент

# insert вставляет элемент в определенное место в списке
vlans.insert(1, 15)             # вставит число 15 после первого элемента, остальные индексы сместит

-----------------------------------------------------

# !!! В Python переменные это ссылки (метки) на данные
vlans1 = [1, 2, 3]
vlans2 = vlans1                 # vlan2 будет ссылаться на туже область памяти как и vlans1
vlans1.append(100)              # значение 100 добавиться и в список vlans1 в список vlans2  

# убедиться можно посмотря на что ссылаются переменные (на одну и ту же ечейку памяти)
id(vlans1) 
id(vlans2)

# можно делать копии списков, чтобы у списков были разные ячейки памяти
vlans2 =vlans1.copy()

# или через срез создать копию
vlans2 = vlans1[:]

==============================================================================================

### СЛОВАРИ ###

# 2 вида записи словаря
london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
london = {
    'id': 1,
    'name': 'London',
    'user_vlan': 1010,
    'mngmt_vlan': 99,
    'to_name': None,             # none - нет значения
    'port': 'G1/0/11'
}

# 'name': 'London1'  - ключ: значение,

# доступ к значению по ключу, но по значению ключ найти нельзя (для этого словарь не преднасзначен) (только методом перебора)  
# ключ должен быть неизменяемого типа (число, строка, кортеж), значение может быть любого типа

london["name"]                   # обращение к элементу
value = london["name"]           

london["vendor"] = "Eltex"       # изменить значения для ключа Vendor
london["ip"] = "10.1.1.1"        # добавить в словарь новую пару ключ-значение

# может быть словарь в словаре (очень распространенный вариант)
london_co = {
    'r1': {
        'hostname': 'london_r1',
        'vendor': 'Cisco',
        'model': '4451',
    },
    'r2': {
        'hostname': 'london_r2',
        'vendor': 'Cisco',
        'model': '3925',
    },
}

# модуль pprint используется для красивого отображения сложных словарей
from pprint import pprint
pprint(london_co)

london_co["r2"]["model"]            # "3925"  - обращение к подсловарю 
london_co["r2"]["model"] = "7206"   # изменить модель R2

len(london_co)                      # количество ключей
sorted(london_co["r1"])             # отсортировать в словаре r1, сортировка только по ключам работает

del london["name"]                  # удалить ключ name

london.clear()                      # обнулить/очистить словарь
# или
london = {}

# Копия словаря методом указания что один словарь равен другому означает, что копируются ключи словаря, а значения это ссылки на другой словарь
# лучше копировать методом copy
london2 = london.copy()

# Метод get
london.get("nam")                   # если такого ключа нет, то ошибки не будет, а просто вернется None
london.get("nam", "No Key")         # можно вернуть любое свое значения, если такого ключа нет, например No Key

"vendor" in london                  # узнать если ключ vendor в словаре london (вернет либо True либо false)

london.keys()                       # получить все ключи
london.values()                     # получить все значения
london.items()                      # получить все пары ключ-значение

london_co["r1"].keys()              # получим список ключей подсловаря

# keys, values, items - специальные типы данных которые являются ссылками на словари, меняются вместе со словарем
keys_1 = london.keys()              # нельзя потом обратиться к keys_1[0], но можно сделать следующее
keys_1 = list(london.keys())        # получим список ключей, можно сделать keys[0]
values_1 = list(london.values())    # получим список значений
items_1 = list(london.items())      # получим список пар в виде кортежа

# метод update - можно суммировать/объеденять словари
r1 = {'name': 'London', 'vendor': 'Cisco'}
r1_new = {'ip': '10.1.1.1', 'vendor': 'Eltex'}
r1.update(r1_new)                                           # в словарь r1 добавится ключ ip и измениться значение ключа vendor

# или так без промежуточной переменной:
r1.update({'ip': '10.1.1.1', 'vendor': 'Eltex'})

# Метод pop
london.pop("name")                                          # взять ключ name и удалить его из словаря
# или можно было сделать так вместо pop:
value = london["name"]
del london["name"]

# Списки подходят под однородные данные, в отличие от словарей
# можно из списков сделать словарь, например
access_1 = ['sw mode access', 'sw access vlan 10']
trunk_1 = ['sw mode trunk', 'sw trunk allowed vlan 10,20']
sw_command = {'access': access_1, 'trunk' = trunk_1}        # access_1 и trunk_1 это ссылки на списки, если изменим переменные то и словарь изменится

# !Некоторые методы нельзя делать прямо в значении в словаре, например 
d = {1: [1,2,3].append(4)}                       # вернет None
# надо делать через промежуточные переменные
d = {1: [1,2,3]}
d[1].append(4)

d[1].insert(2,100)                               #  d -- > {1: [1, 2, 100, 3, 4]}    вставить элемент 100 в значение списка ключа 1 после 2-го элемента

# метод setdefault  -  возвращает значение по ключу. Если ключа нет, то добавляет в словарь с новым значением (Пример в задаче 15_1b)
my_dict = {"vlan1": 100}              
my_dict.setdefault{"vlan1": 200}     #  100
my_dict.setdefault{"vlan2": 300}     #  300  
my_dict                              # {"vlan1": 100, "vlan2": 300}   -  т.к. vlan1 уже был в словаре, то значение не поменялось, а vlan2 не было, он добавился с новым значением

-----------------------------------------------------

# вариант создания словаря с DICT если все значения являются строками
r1 = dict(model="4451", ios="15.4")         # конструктор dict позволяет не использовать кавычки в ключах и скобки

# еще вариат с dict если есть список кортежей
r1 = dict([('model', '4451'), ('ios', '15.4')])

# dict.fromkeys()   - сделать заготовку словаря, если знаешь ключи но нет значений еще, чтобы в него потом к примеру записывать
d_keys = ['hostname', 'vendor', 'ip']
r1 = dict.fromkeys(d_keys)                  #  r1 -->  {'hostname': None 'vendor': None, 'ip': None}

# ПРИМЕР, создать словарь который будет подсчитывать кол-во Vlan на коммутаторах, 
sw1_vlans = [1, 2, 3, 4]                    # список vlan на sw1
sw2_vlans = [1, 3, 4]                       # список vlan на sw2
hostnames = ['sw1', 'sw2']                  # создаем список коммутаторов
all_vlans = dict.fromkeys(hostnames, 0)     # создали словарь с дефолтным значениями 0, -> {'sw1': 0, 'sw2': 0} 
all_vlans['sw1'] += len(sw1_vlans)          # записываем в словарь количество vlan на sw1   ( +=  значит   all_vlans['sw1'] = all_vlans['sw1']) + len(sw1_vlans)
all_vlans['sw2'] += len(sw2_vlans)          # записываем в словарь количество vlan на sw2
print(all_vlans)                            # {'sw1': 4, 'sw2': 3}

==============================================================================================

### КОРТЕЖ (tuple) ###

# Это можно сказать неизменяемый упорядоченный список, вместо [] используется ()
# Кортеж дает возможность в ключах словаря писать несколько элементов (так как список в ключах словаря использовать нельзя)
# Также используется когда данные мы получаем извне (например: из БД, из csv-файла)

data = ('sw1', '10.1.1.1', 'Cisco IOS')
data.count('sw1')                   # 1
data.index('Cisco IOS')             # 2

tuple1 = tuple()                    # пустой кортеж (очень редко, но бывает нужен), обязательно tuple надо указать для пустого кортежа
tuple2 = ('password',)              # кортеж из одного элемента (иногда нужен), обязательно запятая в конце

# Кортеж из списка, tuple - превратить в кортеж
list_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']
tuple_keys = tuple(list_keys)       # ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

tuple_keys[0]                       # 'hostname'
tuple_keys[1:]                      # ('location', 'vendor', 'model', 'ios', 'ip')  - срез

tuple('test')                       # ('t', 'e', 's', 't')                       

# добвить элемент в кортеж
vlans = (1,2,3)
vlans_new = vlans + (4,) + (5,6)    # (1,2,3,4,5,6)

# сортировка
sorted(tuple_keys)                  # сортирует и возвращает список 

==============================================================================================

### МНОЖЕСТВО (set) ###

# Это изменяемый неупорядоченный тип данных, содержатся только уникальные элементы
# используются фигурные скобки, но в отличие от словаря нет пары ключ-значение

vlans = {10,20,30,10,20,1}          # {1,10,20,30}   - уникальные элементы, но необязательно по порядку
names = {'sw1', 'sw2', 'rt1'}

# пример есть список, надо получить список уникальных элементов из него
vlans = [1,2,3,4,3,1,2,1]
list(set(vlans))                    # [1,2,3,4]  

set1.add(5)                         # добавить элемент в множество
set1.remove(4)                      # удалить элемент из множества
set1.update([50,60])                # добавить несколько элементов

# операции с множеством
vlans1 = {1,2,3,4,5}
vlans2 = {3,4,5,6,7}
vlans1.intersection(vlans2)         # {3,4,5} - какие vlan общие
vlans1.difference(vlans2)           # {1,2} - какие vlan есть в множестве vlans1 но нет в vlans2
vlans1.union(vlans2)                # {1,2,3,4,5,6,7} - объединение множеств
vlans1 & vlans2                     # тоже самое что intersection
vlans1 - vlans2                     # тоже самое что difference
vlans1 | vlans2                     # тоже самое что union
vlans1.symmetric_difference(vlans2) # {1,2,6,7} - что уникального в обоих множествах 

set1 = {}                           # это будет пустой словарь
set1 = set{}                        # это будет пустое множество, так создается со словом set

==============================================================================================

### БУЛЕВЫ ЗНАЧЕНИЯ (Boolean) ###

None
True
False
# регистр имеет значение, если с маленькой буквы то уже будет переменные

s = 'hello'
s.startswith('h')       # True
                        
vlans = [1,2,3,4]       
5 in vlans              # False

# Ложные значения:
- 0
- None
- пустая строка
- пустой объект

# Остальные истинные значения
- любое ненулевое число
- любая непустая строка
- любой непустой объект

# bool - проверяет истинное значение или ложное
bool(vlans)            # True
bool(2)                # True
bool([])               # False
bool(0)                # False

if vlans:              # если не равно 0
# или тоже самое
if len(vlans) != 0:

==============================================================================================

### ПРЕОБРАЗОВНИЕ ТИПОВ ###

int()                  # преобразование строки в число
bin()                  # дяситичное число в двоичное
hex()                  # дяситичное число в 16-ричное
list()                 # преобразует аргумент в список 
set()                  # преобразует аргумент в множество уникальных элементов
tuple()                # преобразует аргумент в кортеж
str()                  # преобразует аргумент в строку

### ПРОВЕРКА ТИПОВ ###

# есть куча методов для строк is...
isdigit()              # проверить состоит ли строка из одних цифр
isalpha()              # проверить состоит ли строка из одних букв
"a10".isdigit()        # False    (если будет True то можно будет строку к примеру в число превратить)  
"abc".isalpha()        # True

type()                 # функция проверяет тип перменной
type(aaa)              # Если aaa - строка, то вернет str, если aaa - список то вернет list и т.д
if type('aaa') == str: # потом применяем в условии

==============================================================================================

### СОЗДАНИЕ БАЗОВЫХ СКРИПТОВ ###

Чтобы сделатьфайл исполняемым в linux надо в первой строке написать shebang
#!/usr/bin/env python
либо
#!/usr/bin/env python3

# после этого дать права на запуск файла
chmod +x access_template_exec.py

# и запускать след. образом без указания слова python
./access_template_exec.py

-----------------------------------------------------

### Передача аргументов скрипту с помощью argv ###

# в argv все передается как строки, если нужно передать как число то надо конвертировать int

# первый способ
import sys
vlan = sys.argv[1]                  # говорим что Vlan получить из аргумента с индексом 1, (индекс 0 - это всегда имя скрипта)
                
print(sys.argv)                     # напечать аргументы, которые мы передаем в скрипт при запуске скрипта
 
# второй способ
from sys import argv
vlan = argv[1]

#  запуск скрипта
python access_template_argv.py 5       

-----------------------------------------------------

### Передача аргументов с помощью input ###

# Функция input - передать информацию скрипту по запросу, аргументы передаются в input тоже как строки

vlan = input("Введи номер Vlan: ")
intf = input("Введи номер интерфейса: ")

input("Нажмите Enter для продолжения")     # сделать паузу в скрипте

==============================================================================================

### ОПЕРАТОРЫ ###
if / elif / else
'''
Принцип как у ACL, если условия выполняется (возвращает true) проверка останавливается, 
elif может быть несколько веток в одном блоке, if только один в блоке, следующий if с таким же оступом будет считаться другим блоком.
можно делать вложенный if (с помощью отступов)
Обязательно только условие if (elif и else необязательно)
'''

if a == 10:
    print('a равно 10')
elif a < 10:
    print('a меньше 10')
else:
    print('a больше 10')

list_to_test = [1, 2, 3]                
if list_to_test:                           #  можно так сократить
    print("В списке есть объекты")
# или так можно сделать
if len(list_to_test) != 0:
    print("В списке есть объекты")

# можно писать в одну строку но это плохой тон, только если одно условие if используется
# или редкий пример (трехнарное выражение)
result = True if len(s) > 5 else False

-----------------------------------------------------

# Оператор in (входит ли элемент куда-то, в списке, в множестве, в кортеже. В словаре проверяет ключи. В строке есть ли подстрока)
if 'access' in line
    print(line)
    
'Fast' in 'FastEthernet'                   # True

string1 = "switchport mode trunk"       
'trunk' in string1                         # True
'trunk' not in string1                     # False
'access' in string1 or 'trunk' in string1  # True

vlan = [10, 20, 30, 40]
50 in vlan                                 # False

r1 = {
    'IOS': '15.4',
    'IP': '10.255.0.1',
    'hostname': 'london_r1',
}
'IOS' in r1 and 10 in vlan                 # можно применять операторы and, or, not
('IOS' in r1) and (10 in vlan)             # или так

# Есть приоритность операторов, посмотреть в документации на сайте можно
# Всегда можно посмотреть что нового в новой версии Python (What is new in Python 3.9)

# Если с оператором and все значения истина, то возвращается последенее значение элемента, а не true/false
"line1" and "line2" and "line3"            # line3  вернется

# Если с оператором and есть ложное значение, то возвращается первое ложное значение элемента, а не true/false
"line1" and "" and "line3"                 # ""  вернется

# Удобро предварительно проверять с оператором and последовательно условия, например:
a = '10'
a.isdigit() and int(а) > 5                 # т.е. если строка 'a' состоит из чисел, то вычисляем 'a' и проверям на условие. 
                                           # а если 'a' это не число, а к примеру a = "a", то вернется False и дальше проверяться не будет (а значит и ошибки не будет в выражение int(а))    

# Если с оператором or есть истиные значения, то возвращается первое истиное значение, а не true/false
"line1" or ""                              # "line1"    вернется

# Если с оператором or все значения ложные, то возвращается последнее ложное значение
"" or False or 0                           # 0  вернется

& - and                                    # можно писать символами но принято писать словами 

-----------------------------------------------------

# ПРИМЕР КАК СО СЛОВАРЕМ МОЖНО УПРОСТИТЬ КОНСРУКЦИЮ IF 

cfg = input("Введите что надо настроить: ")
if cfg == "access":
    print("access_cfg")
elif cfg == "trunk":
    print("trunk_cfg")
elif cfg == "vpn":
    print("vpn_cfg")
else:
    print("такой конфигураии нет")

# проще со словарем
cfg = input("Введите что надо настроить: ")    
cfg_dict = {
    "access": "access_cfg",
    "trunk": "trunk_cfg",
    "vpn": "vpn_cfg"
}
if cfg in cfg_dict:
    print(cfg_dict[cfg])
else
    print("такой конфигураии нет")

==============================================================================================

### ЦИКЛЫ ###

Цикл for

# Применение: перебор строк, словаря, списка, функция range(), любой итерируемый объект
# for работает в списке со значениями а не с индексами, в словаре перебирает ключи

for letter in 'Test string':
    print (letter)                         # перебрать буквы и вывести на печать
                                           # letter произвольное название переменной
vlans_list = [1,2,3,4]
vlans_str = []
for each_vlan in vlans_list:
    print(each_vlan * 100)                 # перебрать список vlan и что-то сделать с каждым vlan
    vlan_str.append(str(each_vlan))        # превращаем vlan из числа в строку и добавляем в другой список
print(vlan_str)   

# Пример: из строки с IP сделать список чисел из октетов IP
ip = "192.168.100.1"
octets = ip.split(".")  
octets_int = []
for octet in octets:
    octets_int.append(int(octet))          # [192, 168, 100, 1]

# Функция range - особый тип данных, создается по мере необходимости

range(1,5)                                 # диапазон чисел от 1 до 5 не включая 5
list(range(1, 5))                          # будет список [1, 2, 3, 4]

for number in range(11):                   # диапазон от 0 до 10
    print(f"interface Gi0/{number}")       # выведет список интерфейсов
    print(f" description vlan_{number}")

# for со словарем
r1 = {
    'IOS': '15.4',
    'IP': '10.255.0.1',
    'hostname': 'london_r1',
}
for key in r1:
    print(key, r1[key])                    # перебор словаря и вывод ключей, а также и значений ключей
    
for key in r1:
    print(f"{key:20}{r1[key]}")            # вывести красиво с выравниваем первого столбца

# Можно также вывести ключ-значение из словаря с помощью РАСПАКОВКИ ПЕРЕМЕННЫХ:

for item in r1.items():                    # r1.items() - отдельный тип, список кортежей
    print(item)                            # выведем кортежи ключ-значение, 
    key, value = item                      # распаковка item
    print(key, value)                      # печатаем ключ-значение

# Или проще
for key, value in r1.items():
    print(key,value)                       # вывод такой же как и без распоковки, 
                                           # но удобно тем, что есть 2 переменных (ключ и значение) теперь и можно с ними что-то делать

-----------------------------------------------------                            
# Вложенные циклы for

commands = [
    'switchport mode access',
    'switchport access vlan 10',
    'spanning-tree portfast',
    'spanning-tree bpduguard enable']
fast_int = ['0/1','0/3','0/4','0/7','0/9','0/10','0/11']

for intf in fast_int:              # создаем для каждого интерфейса конфигурацию
    print(f"interface {intf}")
    for cmd in commands:           # вместо вложенного цикла можно было также сделать join переменной commands по переводу строки, но с циклом проще
        print(cmd)         

# с условием цикл, подставляем из словаря интерфейс и назначаем соответсвующий vlan, а также другие команды

commands = [
    'switchport mode access',
    'spanning-tree portfast',
    'spanning-tree bpduguard enable']
access = {'0/12': 10, '0/14': 11, '0/16': 17, '0/17': 150}

for intf in access:
    print(f"interface {intf}")
    vlan = access[intf]
    for cmd in commands:
        print(cmd)
    print(f"switchport access vlan {vlan}")
         
# или с распоковкой
for intf, vlan in access.items():
    print(f"interface {intf}")
    for cmd in commands:
        if cmd.endswith("vlan"):
            print(f" {cmd} {vlan}")
        else: 
            print(f" {cmd}")

-----------------------------------------------------

Цикл while 

# если есть условие, но в отличие от if после выполнения условия возвращаемся в начало цикла

a = 5
while a > 0:
    print(a)
    a = a - 1       # a -= 1

vlans = [10, 20, 30, 40]
i = 0
while i < len(vlans):
    print(vlans[i])
    i += 1
    
# или с for удобнее
for vl in vlans:
    print(vl)

# !!! Пример с while - с паролем пользователя в отдельном файле  !!!

У циклов for и while есть бывает конструкция else, но это редко используется
 
-----------------------------------------------------

Оператор break  -  прерывание цикла (используется в for и while), относится только к ближайшему циклу

while True:                 # Значит бесконечный цикл
    .....
    break

-----------------------------------------------------

Оператор continue - возвращает в начало цикла

for num in range(5):
    if num == 3:
        continue
    else:
        print(num)          # выведет на печать все числа кроме 3

-----------------------------------------------------

Оператор pass  -  ничего не делаем в этом месте, временная заглушка, для того чтобы писать дальше код 
# к примеру мы не знаем что в условии писать пока, указываем pass и ошибки не будет (в else писать pass бесмысленно, можно else убрать)

==============================================================================================

### РАБОТА С ИСКЛЮЧЕНИЯМИ ### 
try / except / else / finally

input_1 = input("Введите число: ")
num1 = int(input_1)                         # Если ввели не число, то в этом месте будет Исключение ValueError (определенная ошибка) и код прервется
                                            # значит сначала делаем проверку
if input_1.strip().isdigit():               # удаляем спец.символы в конце и начале, и провереяем что эта введенная строка состоит из чисел, а потом только переводим ее в число
    num1 = int(input_1)
    print("Ок")
else:
    print("Надо вводить только числа")

# В документации на фунцкиям (методы) есть описание Исключений (какие ошибки возникают если что то неправильно сделали или написали)
# Простой способ посмотреть какое исключение появляется, специально предварительно в ipython к примеру воспроизвести его

Конструкция try / except  -  позволяет перехватывать исключения

input_1 = input("Введите число 1: ")
input_2 = input("Введите число 2: ")
try:
    num1 = int(input_1)
    num2 = int(input_2)
    print(num1/num2)                       # для примера еще одного исключения
except ValueError:                         # обрабатываем ситуацию когда введено не число, ошибки не будет, а сделали перехват исключения и предупреждаем
    print("надо вводить только числа")
except ZeroDivisionError:                  # обрабатываем ситуацию, когда может быть деление на 0, т.е. можем несколько исключений (ошибок) перехватывать
    print("возникла ошибка, на ноль делить нельзя")
    
else:                                      # Может указать else, если except у нас не отработал (не было исключений-ошибок)
    print(num1 * num2)                     # что-то можем делать, еlse нужен чтобы мы могли что-то с этими переменными сделать, если надо
                                           # если были бы исключения, то переменным бы ничего не присвоилось и без else мы бы получили ошибку
finally:                                   # что-то в конце сделать, редко применяется, можно без него обойтись
    print("!!!")                           

# в except можно не указывать конкретное исключение, но это плохая практика

# Можно except объединять
except (ValueError, ZeroDivisionError):
    print("надо вводить только числа и число 2 не должно быть равно 0")

# можно вывести на экран какая ошибка если несколько исключений
except (ValueError, ZeroDivisionError) as error:
    print(error)
    print("надо вводить только числа и число 2 не должно быть равно 0")
                                           
# Пример для чего нужны исключения
# Если мы подключаемся к множеству оборудования и на каком то возникла ошибка, то на остальное оборудование надо продолжить подключаться

ip_list = ["10.1.1.1", "10.1.1.2", "10.1.1.3"]
for ip in ip_list:
    print(f"Подключаюсь на {ip}")
    try:
        connect(...)                                             # будто подключаемся к оборудованию
    except TimeoutError:
        print(f" оборудование {ip} не доступно по таймауту")
    except AuthenticationError:
        print("Логин или пароль неправильный")
    print(f"{ip} отработало")

# Генерация исключений, просто пример
try
    if ip == "10.1.1.1"
        raise ValueError("При подключении возникла ошибка")      # сгенерировать в этом месте исключение 
    except ValueError as error:
        print(f" оборудование {ip} не доступно по таймауту")
        print(error)

==============================================================================================

### РАБОТА С ФАЙЛАМИ ###

- конфигурации (неструктурированные текстовые файлы)
- шаблоны конфигурации (например jinja)
- файлы с параметрами подключений (структуированные yaml, json, csv)
- другие скрипты

Аспекты:
- открытие/закрытие
- чтение
- запись

open()                # функция открытия файла, возвращает объект

file1 = open('file_name.txt', 'r')

# Режимы открытия файлов:
r         # только чтение (по умолчанию)
r+        # чтение и запись
w         # для записи (если файл существует, то содержимое его удаляется, если не существует, то создается новый файл)
w+        # чтение и запись (если файл существует, то содержимое его удаляется, если не существует, то создается новый файл)
a         # открыть файл для дополнения записи. Данные добавляются в конец файла
a+        # открыть файл для чтения и записи. Данные добавляются в конец файла

file1.read()          # метод read - считать содержимое файла в одну строку

file1.seek(0)         # установить условный курсор в начало файла, так как после того как считали файл, курсор установиться в конец (редко нужно)

file1.readlines()     # метод read - считать содержимое файла в список строк

# Считывание файла методами read и readlines происходит в память, что иногда не очень хорошо, если большой файл

# Лучше построчно считывать в цикле for строки из файла
for line in file1:     
    print(line)     
# здесь print добавляет доп. перевод строки, поэтому лучше удалять его справа методом rstrip 

# !!! Часто используемым способ вывести содержимое файла !!!
for line in file1:          
    print(line.rstrip())

# Есть еще метод readline - считывает по одной строке каждый раз, удобен в редких случаях
file1.readline()
           
# Пример вывести содержимое файла с помощью readline:
while True:
    line = file1.readline()
    if not line:            #  когда строка не истинная (уже пустая) то выходим из цикла
        break
    print(line)
#

lines1 = file1.readlines()               # записали строки файла file1 в список lines1
f_out = open("results1.txt", "w")        # открыли другой файл result для записи
f_out.write("line_test\n")               # записать в файл строку (слово line_test)
f_out.writelines("lines1")               # записать в файл строки из списка lines1
f_out.close()                            # закрыть файл

# Не всегда вышеуказанная конструкция отрабатывает, 
# бывает так, что случилась ошибка (исключение) и файл не закрылся, тогда можем потерять данные
# поэтому лучше для записи с файлами работать через менеджер контекстов !!!!!!!!!!! 

!!!!!!!!
# Отрытие файла с помощью менеджера контекста, закрытие файла не требуется
# файл автоматически закроется когда появится строка без отступа 

with open("result1.txt", "а") as f_out:             # пример добавить в файл
    for line in lines1:
        f_out.write(line)
        
with open("show_run_interfaces.txt", "r") as f:     # пример считать файл и вывести
    for line in f:          
        print(line.rstrip())
# или
with open("show_run_interfaces.txt", "r") as f:
    print(f.read())

# работа с несколькими файлами через менеджер контекстов
# Пример взять опр.строки из одного файла и записать в другой

with open("sh_ip_int_br.txt", "r") as f_read, open("resul.txt", "w") as f_write:
    for line in f_read:
        if line.starswith("FastEthernet"):
            f_write.write(line)  

# можно записать конструкцию следующим образом
with open("sh_ip_int_br.txt", "r") as f_read:
    with open("resul.txt", "w") as f_write:
        for line in f_read:
            if line.starswith("FastEthernet"):
                f_write.write(line)


# Работа с множеством файлов

files = ["sh_cdp_r1.txt", "sh_cdp_r2.txt", "sh_cdp_r3.txt", "sh_cdp_sw1.txt"]
# print(files) проверить

# или
from glob import glob
files = glob("sh_cdp_*.txt")

for file in files:                      # перебираем файлы
    with open(file, "r":) as f:         # открываем файл
        print(file)                     # выводим на печать имя файла
        for line in f:                  # перебираем строки в файле 
            if "Eth" in line:           # выбираем строки с содержимым "Eth" и печатаем их
                print(line.rstrip())

# Указание пути к файлам

path = "/home/root/repos/pyneng/example1"     # указали путь для файлов (в виде строки)
f1 = "data1.txt"                              # указать имя в файла в переменной
with open(f"{path}/{f1}", "r") as f:

# или
f2 = "/home/repos/pyneng/example2/data2.txt"  # указать пути с файлом
with open(f2, "r") as f:

-----------------------------------------------------

### ПРИМЕРЫ с файлами в файлах 
# script_sh_ip_int_br.py
# script_sh_ip_interface.py
# parse_cfg_section.py

# Разбивка файла с выводом на секции

with open("config_r1.txt", "r") as f:
    output = f.read()

output.split("\n")      # разбить вывод построчно по переводу строки
output.split("!")       # разбить вывод построчно по блокам (секциям). Если в конфиге есть "!"
output.split("!\n")     # получше вывод, строка начинатся будет не с "\n"

cfg_sections = output.split("!\n")

for section in cfg_sections:              # вывод конфига по секциям
    print(section)
    print("="*50)
    
for section in cfg_sections:              # вывод только секций с настройками интерфейсов
    if section.startswith("interface"):
        print(section)
        print("="*50)
        
==============================================================================================

### ФУНКЦИИ ###

# именованный блок кода, который выполняет определенные действия (Например:len, sorted)
# у функции есть входящие параметры и выходные данные. Позволяет не повторять код, в основном для однотипных действий предназначена.
# Функция может быть определена в другой файле(скрипте)
# Функции могут быть опрелены в коде в произвольном порядке (если даже одна использует другую и выполняется раньше другой)
# Функция main (так принято называть) выполняется последней и между функциями принято делать 2 пустые строки

# Пример функции
def open_file(filename):
    """ Docstring """
    with open(filename) as f:
        print(f.read())

def sum(a, b):          # создание функции, передаем параметры a,b, название параметров произвольное
    print(a + b)
sum(1, 3)               # вызов функции, передаем аргументы 1,3

# Функция main()  -  произвольная своя функция, так принято называть основную функцию скрипта

# Операрот return  -  то что возврашает функция, то что можно присвоить переменной потом
def sum(a, b):  
    print("Function sum")
    return a + b
result = sum(1, 3)

# Функция может возвращать все что угодно (например: список, словарь или несколько списков, несколько словарей)
def ping_ip_list(ip_list):
    reachable = [1, 2, 3]                     # условные IP
    unreachable = [5, 6]
    return reachable, unreachable             # вернуть 2 значения, технически это кортедж (с двумя списками в нашем случае) (можно указать без скобок, а можно со скобками)
    # return (reachable, unreachable)
ping_ip_list(test_ip_list)                    # ([1,2,3], [5,6])  вернеться такой кортедж

ip_ok, ip_no_ok = ping_ip_list(test_ip_list)  # при распоковке переменных получим два списка, один с доступными IP, второй с недоступными

---------------------

"""Правило LEGB  -  как Python ищет переменную, в каком порядке
L (Local) - в локальной (внутри функции)
E (enclosing) - в локальной области объемлющих функций (это те функции, внутри которых находится наша функция). Редкий прием, не используем 
G (global) - в глобальной (в скрипте) 
B (built-in) - во встроенной (зарезервированные значения Python)"""

# Переменные внутри функции не видны снаружи !!! 
# Глобальные переменные видны внутри функции, но сначала они ищутся внутри функции
num1 = 10
def sum(num1, num2)
    print(f"{num1=} {num2=}")       # num1=  - синтаксис с Python 3.8, покажет вывод ввиде num1=10
    sum_int = num1 + num2
    return sum_int
result = sum(100, 200)              # результат 300, хоть и переменная num1=10, но она глобальная, сначала python просматривает локальную переменную функции, которая передается ему
print(num1)                         # выведет 10
print(sum_int)                      # будет ошибка, т.к. скрипт не знает такую переменную, которая внутри функции

----------------------
# Пример с проверкой пароля

username = input("Введите имя пользователя: ")
password = input("Введите пароль: ")

def check_passwd(name, pas):
    if len(pas) < 8:
        print("Пароль слишком короткий")
    elif name.lower() in pas.lower():                      
        print("Пароль содержит имя пользователя")
    else:
        print(f"Пароль для {name} прошел все проверки")
        
check_passwd(username, password)

# в примере ничего не возвращается (нет return), значит возвращается None
result1 = check_passwd(username, password)      
print(result1)                              # None

# !!! return в функции может быть несколько, при первом возвращении return работа функции завершается

# Если мы хотим что-то вернуть в этой функции, то можно так сделать
def check_passwd(name, pas):              # создали функцию, которая проверяет пароль и вовращает True или False 
    if len(pas) < 8:
        return False
    elif name.lower() in pas.lower():                      
        return False
    else:
        return True
data = [                                  # создали список списков с пользователь/пароль
    ["user1", "jsadhkjasd"],
    ["user2", "20"],
    ["user3", "user3jsadhkjasd"],
    ["user4", 20],                        # неверные входные данные (число), для случая с исключением (см. ниже)
]
correct_users = []                        # создали пустой список, в который запишем пользователей с корректным паролем
wrong_users = []                          # создали пустой список, в который запишем пользователей с некорректным паролем
for user, passwd in data:                 # перебираем список (с распоковкой)
    check = check_passwd(user, passwd)    # применяем нашу функцию к каждой паре пользователь/пароль
    if check:                             # если функция вернула true, значит паролькорректный 
        correct_users.append(user)        # добавляем "корректных" пользователя в наш новый список
    else:
        wrong_users.append(user)          # добавляем "некорректных" пользователя в наш новый список
print(correct_users)                      # выводим список пользователей с корректным паролем (user1 только выведет)
print(wrong_users)                        # выводим список пользователей с некорректным паролем (user2, user3 выведет)

# В нашей функции мы должны передавать строки, так как внутри есть метод .lower который работает со строками, при передачи чисел будет ошибка
# Надо делать проверку в начале функции (подойдет такой вариант для использоавния)

def check_passwd(name, pas):
    if type(name) != str or type(pas) != str:
        print("Надо передавать строки!")
        return                            # экстренно завершили функцию, ничего ей не возвращаем, только возвращаем print (предупреждение), user4 попадет в список wrong_users
    if len(pas) < 8:
    ...
# Но лучше делать с исключением (более правильно с точки зрения кода), тогда функция не вернет None, но мы узнаем что-то не так пошло (предупреждение - "Надо передавать строки!") и ошибки не будет и этого пользователя не добавит в список с некорректным пользователями  

def check_passwd(name, pas):
    if type(name) != str or type(pas) != str:
        raise ValueError("Надо передавать строки!")
    if len(pas) < 8:
    ...
    
for user, passwd in data:             
    try:                                            # обработка нашего исключения, user4 не попадет в список wrong_users
        check = check_passwd(user, passwd)
    except ValueError as error:
        print(error)
    else:
        if check:                         
            correct_users.append(user)    
        else:
            wrong_users.append(user)      
            
-------------------------
'''
Типы параметров функции:
- обязательные
- необязательные (опциональные, параметры со значением по умолчанию)
'''
def check_passwd(username, password, min_len=8):        # сначала обязательные параметры
    if len(passsword) < min_len:
    ...
check_passwd("user1", "pass1", 3)       # передали необязательный параметр min_len и переопределили его на 3

# Параметры функции надо передавать по порядку, как определены в функции
# Но можно передавать не по порядку, если используем ключевую конструкцию
# В таком случае надо чтобы имена передающих аргументов (ключевых аргументов) совпадали с именами параметров в самой функции 
# Можно ключевые аргументы использовать только для необязательных параметров, чтобы понятнее было что передаем, но тогда по порядку передаем обязательные параметры, а необязательные как хотим (или можно часть не передавать) и ключи для всех необязательных параметров

check_passwd(password="pass1", min_len=8, username='user1')
check_passwd("user1", "pass1", min_len=8)

# можно запретить передавать без ключевых аргументов, вставив "*,"  после обязательных (позиционных) аргументов(т.к. бех них с точки зрения Python это некрасиво)

check_passwd(username="user1", password="1234", *, min_len=4, check_numbers=True)

# Например, встроенные функции с необязательными параметрами требуют указания ключевых аргументов
sorted(iterable, /, *, key=None, reverse=False)     # так выглядит подсказка по функции sorted
# iterable - позиционный аргумент
# key, reverse - ключевой аргумент
# "/" - означает что обязательные (позиционные аргументы) передаются без ключей только
# "*," - означает что следующие необязательные аргументы передаем только как ключевые (т.е. необязательно все передавать, но если передаем то ключ обязательно указываем) 

sorted(vlans, reverse=True)          # reverse - необязательный параметр, поэтому передаем как ключевой аргумент
sorted(vlans, True)                  # будет ошибка
sorted(iterable=vlans, reverse=True) # будет ошибка, т.к. есть "/" после позиционного аргумента

# Аннотация функции - подсказка по типам параметров которые передавать надо (большая тема для изучения)
check_passwd(username: str, password: str, min_len: int = 8, check_numbers: bool = False)

----------------------------------

# Позиционные аргументы переменной длины (*args)   (имя аргументов рекомендуется - args)(не часто применяется)

def sum(*args)               # передать любое количество позиционных аргументов
    print(f"{args=}")
    result = 0
    for i in args:           # аргументы передаются в виде кортеджа, в данном случае в цикле перебор элементов кортеджа будет происходить 
        result += i
    return result
sum(1)             -> 1      # args=(1,)
sum(1, 2)          -> 3      # args=(1,2)
sum(1, 2, 3, 4, 7) -> 17     # args=(1,2,3,4,5)

# Ключевые аргументы переменной длины (**kwargs)   (имя аргументов рекомендуется - kwargs)    
# !!! Урок 8.3 (30 минута) - объяснение как облегчают жизнь такие аргументы на примере подключения к оборудованию
# Также пример в файле example_file_with_function.py (пример 4)

def sum(**kwargs)            # аргументы передаются в виде словаря (запаковка ключевых аргументов в словарь)
    print(f"{kwargs=}")      

sum(a=1, b=2, test=True)     # kwargs={'a': 1, 'b': 2, 'test': True}

# Пример с объяснением:
params = {'min_len': 4, 'check_numbers': True}         # есть какая-то переменная - словарь
func(**params)   '''вызов цункции превращает в -->'''  func(min_len=4, check_numbers=True)     # (распаковка словаря в ключевые аргументы)

# Плохая практика в целом делать так например:
def check_password(*args, *kwargs)
# надо будет внутри функции делать проверка на количество переданных аргументов, чтобы не было ошибок
# но такие функции имеют место быть в жизни (в основном функциях которые являются оберткой чего-либо, перенаправляют эти аргументы внуть другой функции например)

--------------------------------------------
# Распаковка переменных, как позиционных аргументов (через '*')

ip_template = "{:08b} {:08b} {:08b} {:08b}"
octets = [10, 12, 50, 4]
ip_template.format(octets[0], octets[1], octets[2], octets[3])  # слишком сложно выглядит
ip_template.format(*octetc)                                     # можем распокавать так, передав элементы списка как отдельные позиционные аргументы

# еще пример распаковки 
commands = ['int fa0/0', 'ip address ...']
all_commands = ['conf t', *commands, 'end']     # распоковали внуть другого списка,  all_commands = ['conf t', 'int fa0/0', 'ip address ...', 'end'] 


==============================================================================================

### РАСПАКОВКА ПЕРЕМЕННЫХ ###

interface = ["Fa0/1", "10.1.1.1", "up", "up"]
intf, ip, status, protocol = interface           # intf = interface[0], ip = interface[1] ....

data = ["Fa0/1", "10.1.1.1", "up", "up"]
intf, ip, _, _ = data                            # из списка нужны только 2 первых элемента, "_" - означает что эти значения переменных не нужны (так принято)

dhcp = ["XX:XX:XX:XX:XX:XX" , "10.1.10.2", "86250", "dhcp-snooping", "FastEthernet0/1"]
mac, ip, *other = dhcp                           # other --> ["86250", "dhcp-snooping", "FastEthernet0/1"]  
mac, ip, *_, intf = dhcp                         # _ --> ["86250", "dhcp-snooping"]     (удобно, если посередине много элементов и разное количество их)

"""
#  4 случая использовать звездочки "*"

def f(*args)                     # собираем все позиционные аргументы в кортедж
    pass

octets = [10, 20, 30, 40]
ip_template.format(*octetc)      # передать элементы списка как отдельные позиционные аргументы

a, b, *c, d = [1, 2, 3, 4, 5, 6]            # распаковка переменных

commands = ['int fa0/0', 'ip address ...']  # тоже распаковка переменных
all_commands = ['conf t', *commands, 'end'] 
"""

==============================================================================================

### ГЕНЕРАТОРЫ СПИСКОВ (СЛОВАРЕЙ, МНОЖЕСТВ) ###  (list comprehensions)

# Это выражение вида:
vlans = ['vlan {}'.format(num) for num in range(10,14)]
print(vlans)                                            # ['vlan 10', 'vlan 11', 'vlan 12', 'vlan 13']

# это аналогично следующей записи
vlans = []
for num in range(10,14):
    vlans.append('vlan {}'.format(num))

# Пример (перевести список чисел в список строк)
vlans = [1, 2, 3, 4]
vlans_str = []
for vl in vlans:
    vlans_str.append(str(vl))

vlans_str = [str(vl) for vl in vlans]       # с помощью генератора, намного удобнее

# Пример (отобрать элементы с числами и сделать из них список чисел)
data = ["11", "2", "sdhb", "100", "b"]
digits_only = []
for item in data:
    if item.isdigit():
        digits_only.append(int(item))

digits_only = [int(item) for item in data if item.isdigit()]        # с помощью генератора в одну строку сделали

# Пример с вложенными списками (сделать один плоский список)
vlans = [[10, 21, 35], [101, 115,150], [111, 40, 50]]
data = []
for vl_list in vlans:
    for vl in vl_list:
        data.append(vl)

data = [vl for vl_list in vlans for vl in vl_list]      # сложнее воспринимать такой генератор

# Генератор мнеожеств получается путем простой замены скобок на фигурные скобки
data = {vl for vl_list in vlans for vl in vl_list}      # {10, 21, 35, 101, 115,150, 111, 40, 50}

# Генератор словарей
# Пример с преобразованием ключей в нижний регистр
r1 = {
    'HOSTMAME': 'london_r1',
    'IP': '10.1.1.2',
    'vendor': 'Cisco',
    'model': '4451',
}
new_r1 = {}
for key, value in r1.items():
    new_r1[key.lower()] = value

new_r1 = {key.lower(): value for key, value in r1.items()}      # с помощью генератора

# создать новый словарь и отфильтровать в нем по ключам
keys = "ip vendor model".split()    # keys ["ip", "vendor", "model"] 
for key, value in new_r1.items():
    if key in keys:
        r1_filter[key] = valiue
        
r1_filter = {key: value for key, value in new_r1.items() if key in keys}    # с помощью генератора

# если в генераторе случчайно вместо [] указать (), то это не сработает, но в определенных случаях например с join сработает ( "()" - другой генератор совсем, отдельно в книжке есть)
vlans = [1, 2, 3, 4]
",".join([str(vl) for vl in vlans])     # "1,2,3,4"
",".join(str(vl) for vl in vlans)       # "1,2,3,4"

==============================================================================================

### Встроенные функции ###      (Built-in Functions)

# эти функции не надо ни откуда импортировать

# Функция print (преобразует вывод в строку и выводит по умолчанию на стандартный поток вывода)
print(*items, sep=' ', end='\n', file=sys.stdout, flush=False) 

print(1, 2, 3, sep="\n")    # сделать между элементами перевод строки к примеру или " | " (по умолчанию между элементами пробел)
print(1, 2, 3, end=" ")     # end - то чем закончить вывод (по умолчанию перевод строки), end="\n\n" - или так к примеру
print(1, 2, 3, sep=f"\n{'='*40}\n")     # элементы на разные строки а между ними '====='

import time
for i in range(10):                    
    print(i, end=" ", flush=True)       # вывести числа в одну строку с задержкой,   Flush - говорит выводить тут же информацию не дожидаясь перевода строки
    print(f"\r{i}", end="", flush=True) # вывести числа на одном месте (заменяя друг друга), можно делать спиннеры (spinner = "|/-\|/-\|/-\|/-\|", for i in spinner)
    time.sleep(0.5)
    # 
--------------------------------------------------------------

# Функция range 
range(stop)
range(start, stop)       
range(start, stop, step)      

# чтобы увидеть результат работы функции надо ее применять где-то в цикле или использовать List
list(range(5))          # [0, 1, 2, 3, 4]
list(range(5, 10))      # [5, 6, 7, 8, 9]
list(range(5, 10, 2))   # [5, 7, 9]         шаг 2
list(range(6, 2, -1))   # [6, 5, 4, 3]      шаг -1

vlan = 150
vlan in range(1, 200)   # True   (самое полезное)

r = range(1, 250)
r[0]             # 1
r[-2]            # 248
r[10:]           # range(11, 250)
len(r)           # 249
min(r)           # 1
max(r)           # 249
r.index(100)     # 99

--------------------------------------------------------------

# Функция sorted   (возвращает новый отсортированный список)

sorted(iterable, /, *, key=None, reverse=False)

# сортировка работает только с однородным списком, происходит сравнение по кодам символов
ord("A")    # посмотреть код символами

# по умолчанию по возрастанию сортировка, регистр имеет значение
sorted(vlans, reverse=True)     # по убыванию сортировка

строка    --- > список символов
файл      --- > список строк
словарь   ----> список ключей
список,множество,кортедж    --- > список 

# чтобы сортировка была правильной, надо список vlan (если он из строк) перевести в числа, 
# но можно указать ключ (какая-нибудь функция или метод, по которой сортировать, можно свою функцию указать)
sorted(vlan, key=int)       # перевести в числа и сортировать     
sorted(r1, key=str.lower)   # сортировка независимо от регистра
sorted(r1, key=len)         # сортировка по длине элементов
# в данных случаях можно разнородный список сортировать

",".join(sorted(vlans, key=int))                # сделать строку из списка строк(vlan) и отсортировать сразу

from operator import itemgetter
sorted(list_of_tuples, key=itemgetter(1))       # сортировка списка кортеджей, но по 2-ому элементу кортеджей

# делаем из словаря список кортеджей и сортируем по списку значений
items = list(r1.items())
sorted(items, key=itemgetter(1))

# сортировка IP-адресов с помощью своей фунукции
ip_list = ["10.1.1.1", "10.30.1.1", "10.1.2.1", "10.1.12.1"]
def bin_ip(ip)
    octets = [int(octet) for octet in ip.split(".")]            # используем генератор списков (делаем список чисел из октетов)
    bin_ip_str = "{08b}{08b}{08b}{08b}".format(*octets)         # используем распаковку переменных (переводим октеты в двоичный формат)

bin_ip("10.1.1.1")               # 00001010000010100000110101101111     -  результат работы фунцкии
sorted(ip_list, key=bin_ip)      # делаем сортировку списка ip-адрсесов по нашей функции, но сами ip не будут переведы в двоичный формат

--------------------------------------------------------------

# Функция enumerate   (перебирает список элементов и генерирует их индекс)

vlans = [10, 20, 30, 40]
list(enumerate(vlans))      # [(0, 10), (1, 20), (2, 30), (3, 40)]      - необходимо применять list, так как enumerate ленивая фунцкия и генерирует список по мере необходимости 

# пример с перебором строк файла и выводом строк с их номерами
with open("config_r1.txt") as f:
    for index, line in enumerate(f, 1):             # enumerate(f, 1)  1 - значит начинать генерировать нумер с первого индекса (по умолчанию с 0)
        print(f"{index:<5}{line}", end="")

# пример c дополнением команд в начале "action 00N "  (используеися в cisco в Event Manager)
with open("command.txt") as f:
    for index, line in enumerate(f, 1):                                # можно и без функции обойтись (ввести переменную index=1 и увеличивать на 1 в цикле ее)
        print(f'action {index:03} cli command "{line.rstrip()}"')      # :03  - выделить 3 символа и недостоющие заполнить нулями

--------------------------------------------------------------

# Функция zip   (собирает несколько последовательностей в одну, группирует элементы из разных последовательностей)

vlans = [10,20,30,40]                               
vlans_name = ["IT","MGMT","Sales","Phone"]

list(zip(vlans, vlans_name))            # [(10, "IT"), (20, "MGMT"), (30, "Sales"), (40, "Phone")]  - делает список кортежей, 
# если будет неодинаковое количество элементов в последовательноси, то обрежеться по меньшей
# может быть 3 и больше последовательностей

# вывод vlan с именем (вариант без функции zip)
for i in range(len(vlans)):             # vlan 10
    print(f"vlan {vlans[i]}")           #  name IT
    print(f" name {vlans_name[i]}")     # vlan 20
                                        #  name MGMT
# Вариант с функцией zip
for vl, name in zip(vlans, vlans_name):
    print(f"vlan [vl]}")      
    print(f" name {name}")

# Можно сделать словарь просто
dict(zip(vlans, vlans_name))            # {10: "IT", 20: "MGMT", 30: "Sales", 40: "Phone"}

# еще пример создания словаря
data = [["Fa0/1", "10.1.1.1", "up", "up"], ["Fa0/2", "10.1.1.2", "up", "up"]]       # например из такой список списков (рапарсенный вывод sh ip int br)
headers = ["inerface", "ip", "status", "protocol"]                                  # делаем список ключей
result = []
for d_list in data:
    item_dict = dict(zip(headers, d_list))                                          # применяеи zip к нашим переменным и делаем словарь 
    result.append(item_dict)                                                        # делаем список словарей
    
# тоже самое через генератор
result = [dict(zip(headers, d_list)) for d_list in data]

# потом легко к такому списку словарей обращаться
for d in result:
    print(d["ip"])  # получим в выводе перечен ip-адресов

--------------------------------------------------------------

# Функция map   (применяет одну и ту же функцию к наборам элементов)

vlans = [10,20,30,40]
list(map(str, vlans))       # ["10","20","30","40"]  сделали все элементы строковые, тоже самое что сделать [str(vl) for vl in vlans]   

#  в map надо передавать столько аргументов, со сколькими работает функция (внашем случае один vlans, т.к. функция str)

--------------------------------------------------------------

# Функция lambda   (анонимная функция, которая не привязана к имени, применяется к набору элементов, удобно использовать в выражениях, где требуется написать небольшую функцию)

# пример без lambda
def sum_arg(a, b): 
    return a + b
    
# пример c lambda 
sum_arg = lambda a, b: a + b

# часто применяется при сортировке
sorted(list_of_tuples, key=lambda tuple_x: tuple_x[1])      # сортировка списка кортежей по 2-ому элементу

--------------------------------------------------------------

# Функция filter   (применяет функцию ко всем элементам последовательности и возвращает итератор с теми объектами, для которых функция вернула True)

vlans = ["10", "20", "30", "40", "abc", "2", "www"]

# пример с отбором из списка только чисел без функции filter
[int(vl) for vl in vlans if vl.isdigit()]

# c функцией filter
list(map(int, filter(str.isdigit, vlans)))      # здесь filter сделал список из чисел, но числа в виде строк, поэтому еще применили map с функцией int   (list - чтобы увидеть результат)

list(filter(lambda x: x % 2 == 0, [1,2,3,4,5,6]))  # [2,4,6]  -  отсортировали только четные числа   ( == 1 - неечтные будут)

--------------------------------------------------------------

# Функции all, any   (говорит True, если все значения True, говорит False, если хотя бы одно False) (если список пустой то True)

# пример с all  (проверить ip на правильность)
ip = "10.1.1.1"
[octet.isdigit() for octet in ip.split(".")]                                    # [True ,True, True, True]  
all([octet.isdigit() for octet in ip.split(".")])                               # [True]   -   проверить что все октеты числа
all([octet.isdigit() and 0 <= int(octet) <= 255 for octet in ip.split(".")])    # проверить, что все октеты числа и в диапазоне от 0 до 255

# пример с any  (вывести конфиг исключая некоторые строки)
ignore = ["duplex", "alias", "Current configuration"]
with open("config_r1.txt") as f:
    for line in f:
        if any([word in line for word in ignore]):                  #  проверяется в цикле слова в стоке, если хотя бы одно есть то ничего не делаем
            pass
        else:
            print(line.rstrip())
      
        
==============================================================================================

### МОДУЛИ ###

# Это обычный текстовый файл с кодом с расширением .py  (или каталог с файлами?)
# Модули полезны тем, что позволяют повторно использовать уже написанный код и не копировать его (например, какую-то функцию, метод, переменную и др.)
# Например, функции (или переменные) можно вынести в отдельный файл, в другом файле писать основной код

# Способы импорта модуля:       # принято писать все импорты в начале файла (после описания)
- import module
- import module as
- from module import object
- from module import *

from sys import argv            # бкдет доступна только функция (список) argv из модуля sys (она импортируется в наше окружение, в текущее пространство имен)
import sys                      # будут доступны все функции из модуля sys через этот модуль (в модуле sys будет выполняться код), доступ к функции или методу будет так: sys.argv

# выбор каким образом импортировать зависит от имен наших переменных
from sys import prefix          # если у нас есть переменная prefix, то не сможем использовать переменную prefix из sys  (или можно запутаться)
import sys                      # придется использовать sys.prefix и тогда точно будем знать откуда эта функция/метод/переменная         

# Если надо много чего-то импортировать с другого модуля или длинные имена то можно сократить имя модуля, например
import concurrent.futures as cf         # сделали сокращение имени модуля
cf.ThreadPoolExecutor                   # обратились к функции из модуля concurrent.futures

# можно в одной строке импортировать несколько модулей, или несколько функций из одного модуля (но так лучше не делать для удобства)
from concurrent.futures import ThreadPoolExecutor, as_completed

from sys import *               # импортировать все из модуля sys в текущее пространство имен (плохая практика, никогда не использовать),   dir() - посмотреть текущее пространство имен

-----------------------

# Чтобы какой-то вывод из собственного импортируемого модуля не попал в вывод нашего скрипта, используется специальная переменная __name__
if __name__ == "__main__":          # значит выполнить код, если модуль не импортируется. Выполнять, если только модуль вызывается напрямую. В том скрипте где импортируем этот модуль, эти строки не будут выполняться.
    print("Тестовая проверка") 

# Принято всегда писать это в коде во всех скриптах, лучше в таком виде:
dev main():
    print("Тестовая проверка")
    ....
if __name__ == "__main__":
    main()

# Если код плоский, не используется импорт собственных модулей, то нет смысла использовать __name__

import sys
sys.path        # пример, как посмотреть в ipython по какому пути python ищет модули (порядок просмотра сверху вниз)

# в одном каталоге скрипты друг друга видят (для импорта не надо дополнительно ничего делать)
# все что стороннее устанавливаем через pip, устанавливается в директорию ...\site-packages (в зависимости от окружения у этого каталога разный путь).

sys.path.append(...)          # добавить свой путь для импорта
sys.path.append("..")         # добавить путь на каталог выше уровнем

# свой скрипт (модули) можно добавить в site-packages и он всегда будет доступен
# !!! можно в site-packages создать свой произвольный файл с расширением pth (например my_script_location.pth) и добавить в него все свои пути, в которые хотим размещать наши модули (скрипты), указывать надо все катологи с полным путем (подкаталоги автоматически не сработают)
# файл .pth автоматически считывается при запуске любого скрипта (это лучший способ)

# в помощью python-package можно собирать пути, делать .exe файлы (но эту тему не проходим, не простая тема)

# в ipython если сделать импорт, то последующие изменения кода не применяться (надо перезапустить ipython и заново делать импорт, (или сделать autoreload??? - подробности не рассказали))

import sys
print(sys.version_info)         # посмотреть версию python в mu-editor

pip install <имя модуля>        # установить сторонний модуль
pip show netmiko                # посмотреть информацию о модуле и его зависимостях
pip show paramiko
pip list                        # посмотреть список всех модулей
pip freeze                      # посмотреть список всех модулей в другом виде
pip install -U netmiko          # обновить модуль
pip install netmiko==3.3        # установить определенную версию модуля (к примеру откатиться после неудачного обновления)
pip list --outdated             # посмотреть какие модули требуют обновления (полезная команда)

python3.8 -m pip install netmiko    # указать конкретно для какого python установить модуль netmiko (это если у нас несколько python, которые находятся не в виртуальном окружении)

# Принято писать импорт модулей в следующем порядке:
1) сначала из стандартной библиотеке                 # (например: import sys, from pprint import pprint)
2) потом сторонние, которые установили с помощью pip # (например: import netmiko)
3) потом свои модули
- между этими тремя импортами принято оставлять пустую строку

# Посмотреть что нам доступно из импортируемого модуля можно через dir()   (если что-то забыли и нету подсказки)
import <имя модуля>
print(dir(<имя модуля>))        # pprint(dir(sys))      покажет все что можно писать после точки в sys

line = ''
pprint(dir(line))               # покажет какие есть методы со строкой

pprint(dir())                   # покажет что у нас в текущем пространстве имен

pprint(locals())                # посмотреть все значения переменных внутри функции в определенном месте/моменте   (т.е в любом месте можно вставить и увидим что творится в коде, некий такой дебаг)
pprint(globals())               # тоже самое посмотреть только в глобальном коде, а не в функции

# если мы например в модуле 3 сделали импорт модуля 2, в котором есть импорт модуля 1, то из модуля 3 будет доступны функции модуля 1.
# но так лучше не делать, лучше всегда импорт делать напрямую, т.е в модуле 3 напрямую импортируем модуль 1 !!!

# если мы импортируем какую-то функцию из другого модуля, а она использует другие модули, то нам эти модули импортировать отдельно не надо

----------
#  Рекомендуемое расположение кода
1) shebang, file encoding
2) docstring модуля
3) импорт (модули стандартной библиотеки, стороннние модули, свои скрипты)
4) константы
5) все функции в произв. порядке
6) код/функции для создания CLI если есть (типа input что-то...) 
7) функция main (или основной код)
8) вызов main (if __name__ == "__main__":)

==============================================================================================

### ПОЛЕЗНЫЕ МОДУЛИ ###

# Модуль subprocess

Модуль subprocess   -   позволяет запускать из python все что угодно что можно запустить из ОС (к примеру ping, git или другой скрипт)
                        может получать вывод или проверять, что команда выполнилась без ошибок
                        (то что можно сделать стандартными модулями Python, то лучше не использовать subprocess)

os.system  -  это устаревший вариант subprocess

subprocess.run() - основная функция для работы с модулем

import subprocess
result = subprocess.run("ls")      # выведет файлы в каталоге 

# в переменной result содержиться объект CompletedProcess(args='ls', returncode=0)
result.returncode     # 0  -  значит выполнено успешно, если 1  -  значит команда выполнилась неуспешно

# передать команду с опциями
result = subprocess.run(["ls", "-la"])     # или
result = subprocess.run("ls -la".split())  

# можно передавать команду с регулярными выражениями (например, которые содержат *), но тогда надо подключить shell
result = subprocess.run(["ls", "-la", "ipaddress/*.py"], shell=True)                # значит запустить shell сначала, а потом выполнить команду

# с shell можно не делить команду на список
result = subprocess.run("ls -la ipaddress/*.py", shell=True)            # выведет в каталоге ipaddress файлы с расширением .py

# длительно выполняющая команда, пока команда будет выполняться, python будет занят (в дальнейшем научимся параллельно запускать команды) 
result = subprocess.run(["ping", "-c", "3", "-n", "8.8.8.8"])

# Пример: (при запуске такого скрипта, весь вывод команды ping будет на выведен на экран)
ip_list = ["8.8.8.8", "8.8.8.4", "10.1.1.1"]
for ip in ip_list:
    result = subprocess.run(["ping", "-c", "3", "-n", ip])      # вывод на экран будет
    if result.returncode == 0:
        print(f"Адрес {ip} пингуется")
    else:
        print(f"Адрес {ip} не пингуется")

# можно перехватить вывод ping на стандартный поток вывода stdout
    result = subprocess.run(["ping", "-c", "3", "-n", ip], stdout=subprocess.PIPE)  # вывода на экран работы утилиты ping не будет
    output = result.stdout
    print(output)                       # вывод будет "байтовая" строка (буква "b" в начале), то есть будут ASCI символы присутствовать и \n, в рускоязычном выводе (кирилице) будут непонятные символы 

# можно также вывести ошибки на стандартный поток ошибок 
# также можно (лучше) установить кодировку, чтобы был нормальный вывод в виде строки а не байтовый вывод (который потом можно парсить)
    result = subprocess.run(
        ["ping", "-c", "3", "-n", ip],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,         # можно потом переменной присвоить, output = result.stdout + result.stderr
        encoding="utf-8")               # subprocess самостоятельно не переводит вывод в строку, надо указать кодировку

# если вывод не нужен когда работает скрипт, то можем указать вместо PIPE так:
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,

# Пример в зависимости от ОС запустить ping
import platform     #  platform.system() - Узнать какая ОС

def ping_ip(ip)
    if platform.system().lower()  == "windows":
        cmd = ["ping", "-n", "1", ip]
    else:
        cmd = ["ping", "-c", "1", ip]
    result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf-8')             
    if result.returncode == 0:
        return True
    else:
        return False
        
if __name__ == "__main__":
    for ip in ip_list:                      # ip_list = ["8.8.8.8", "8.8.8.4", ....]
        status = ping_ip(ip)
        if status:
            print(f"Адрес {ip} пингуется")
        else:
            print(f"Адрес {ip} не пингуется")    

# Метод Popen позволяет в фоне запустить процесс (параллельно), работает быстрее (Пример урок 11.1 в 43-00)
result =  subprocess.Popen(["ping", "-c", "10", "-n", "8.8.8.4"], stdout=subprocess.DEVNULL)
returncode = result.wait()       # дождаться и получить результат

-------------------------------------------

# Модуль os   

Модуль os   -  позволяет работать с файловой системой, с окружением, управлять процессами
               огромный модуль, много документации про него

import os

os.cpu_count()                 # количество процессоров в системе, много чего таково можно вывести

os.mkdir("test")               # создать каталог

os.path.exists("test")         # вернет True если такой каталог уже есть     
os.path.exists("/home/repos")

os.listdir(".")                # список файлов и каталогов в текущем каталоге
os.listdir("../functions")     # список файлов и каталогов в каталоге functions, который находится выше
os.path.isfile(file1)          # проверка, что file1 это файл
os.path.isdir(file1)           # проверка, что file1 это директория

[file for file in os.listdir(".") if os.path.isfile(file)]                                # вывести только список файлов с помощью генератора списков
[file for file in os.listdir(".") if os.path.isdir(file)]                                 # вывести только список каталогов с помощью генератора списков             
[file for file in os.listdir(".") if os.path.isfile(file) and not file.startswith(".")]   # тоже самое только исключили скрытые/служебные файлы

# тоже самое без генератора
all_files = os.listdir(".")
files_only = []
for file in all_files:
    if os.path.isfile(file) and not file.startswith("."):
        files_only.append(file)

# Отделить путь от файла
file = "/home/template/test.py"
os.path.split(file)              # ("/home/template", "test.py")

# Объединить путь с файлом (учитывается синтаксис ОС)
path1 = "/home/template/"
os.path.join(path1, "test.py")    # "/home/template/test.py"

-------------------------------------------

# Модуль ipaddress

import ipaddress

# ipaddress.ip_address()  -  функция позволяет создавать объект IPv4Address или IPv6Address соответственно

# если будет направильный IP то будет исключение ValueError и с помощью Try/Exept обрабатываем его

ip1 = ipaddress.ip_address("10.1.1.1")      # IPv4Address('10.1.1.1')  -  объект такого вида

ip1.is_private      # True (проверка принадлежит ли адес к частному дипазону)
ip1.is_global       # проверить IP глобальный ли он
ip1.is_multicast    # является ли мультикастным адрес
ip1.version         # 4

str(ip1)            # получить строку "10.1.1.1" из объекта. 
print(ip1)          # выведет "10.1.1.1", так как print применяет str

# можно делать проверки с адресами и операции

ip1 > ip2
ip1 == ip2
ip1 + 10        # например пингуем адрес и к следующему прибавляем +1 и тоже пингуем

# "10.1.10.1" > "10.1.2.1"        # False, такое сравнение некорректное, т.к. это строки, но работает так:
# ipaddress.ip_address("10.1.10.1") > ipaddress.ip_address("10.1.2.1")  # True,  объекты сравниваются корректно

int(ip1)                        # это десятичное число будет, поэтому сравнения возможны
ipaddress.ip_address(167837953) # IPv4Address('10.1.1.1')

# сортировка адресов
ip_list = ["10.10.1.1", "10.1.2.1", "10.1.10.1", "10.1.10.1"]
sorted(ip_list)                                                 # некорректная сортировка
ip_list_new = [ipaddress.ip_address(ip) for ip in ip_list]      # превращаем адреса в объекты
sorted(ip_list_new)                                             # правильная маркировка

# или сортировка с помощью map
list(map(ipaddress.ip_address, ip_list))

-------

# ipaddress.ip_network    -   функция для работы с подсетями

s1 = ipaddress.ip_network("10.1.1.1/24")   # проверка на является ли адрес адресом сети, если не является будет исключение ValueError
s1 = ipaddress.ip_network("10.1.1.0/29")   # IPv4Network('10.1.1.0/29')  -  объект такого вида
s1.broadcast_address                       # "10.1.1.7"
s1.with_hostmask                           # "10.1.1.0/0.0.0.7"
s1.with_netmask                            # "10.1.1.0/255.255.255.248"
s1.with_prefixlen                          # "10.1.1.0/29"
s1.num_address                             # 8  -  количество хостов
list(s1.hosts())                           # список всех хостов без адреса сети и бродкаста, hosts - это итератор, поэтому чтобы получить список надо ли list применить либо перебирать в цикле
for ip in hosts():
     print(ip)                             # вывести список хостов

# разбить на подсеть на подсети с маской/30
list(s1.subnets(new_prefix-30))            # [IPv4Network("10.1.1.0/30"), IPv4Network("10.1.1.4/30")]

s1[2]             # IPv4Network("10.1.1.2")  -  можно обращаться по индексу к подсети

ip1 in s1         # True, проверить входит ли ip1 в подсеть s1

------

# ipaddress.ip_interface

ip1 = ipaddress.ip_interface("10.1.1.1/28")    # IPv4Interface("10.1.1.1/28")  - такой объект
ip1.network                                    # IPv4Network("10.1.1.0/28") - найти подсеть к которой принажлежит интерфейс  

# функция проверки IP-адресса на корректность !!!
def check_ip(ip)
    try:
        ipaddress.ip_address(ip)
        return True
    except ValueError:
        return False
        

-------------------------------------------

# Модуль tabulate

tabulate  -  библиотека, которая позволяет красиво отображать табличные данные
             это простой модуль, есть продвинутый модуль rich, который может цветами подсвечивать и т.д.

pip install tabulate        # сторонний модуль, требуется установка

Поддерживает:
1. список списков/кортежей
2. список словарей
3. словарь с итерируемыми объектами. Ключи используются как имена столбцов

from tabulate import tabulate

# 1
print(tabulate(sh_ip_int_br))   # крависивый вывод, где sh_ip_int_br список кортежей

colums = ["Interface", "IP", "Status", "Protocol"]
print(tabulate(sh_ip_int_br, headers=colums)       # вывод таблицы с заголовками 

# 2
data = [{'IP': '10.1.1.1',
    'Interface': 'Loopback0',
    'Protocol': 'up',
    'Status': 'up'},
    {'IP': '100.0.0.1',
    'Interface': 'Loopback100',
    'Protocol': 'up',
    'Status': 'up'}]
print(tabulate(data, headers="keys"))              # вывести список словарей data, заголовками будут ключи в словарях

# 3
vlans = {"sw1": [10, 20, 30, 40], "sw2": [1, 2, 10], "sw3": [1, 2, 3, 4, 5, 10,11, 12]}
print(tabulate(vlans, headers="keys"))             # просто вывести таблично словарь

# можно применять разные форматы таблицы (ключ - tablefmt), их много, посмотреть можно в документации
# tablefmt="grid"
# tablefmt="pipe"
# tablefmt="html"       - html формат для последующего использования где-то

print(tabulate(sh_ip_int_br, headers=colums, tablefmt="grid"))

-------------------------------------------

# Модуль glob

glob  -  специальный синтаксис, похож на регулярки, для получения списка строк с файлами

ls -ls ../function/*.py         # вывести все файлы с расширением .py в каталоге
ls -ls *[1-3]*                  # вывести все файлы в имени которых есть цифры 1,2,3 в текущем каталоге

from glob import glob

glob(pathname, recursive=False) # вывести список файлов в каталоге, ключ recursive - искать ли в каталогах файлы
glob("**/*.py")                 # тоже самое с помощью glob получить список файлов с текущего каталога и вышестоящих
glob("/home/*[1-3]*")

iglob(pathname)                 # тот же glob но это итератор, ленивое вычисление для экономии памяти

-------------------------------------------

# Модуль pprint

pprint  -  модуль позволяет красиво отображать объекты Python, при этом сохраняется структура объекта, очень хорош для траблшутинга
           покажет переносы строк, пробелы, разбивает строку на литералы для удобства отображения, вывод pprint можно взять и вставить в код куда-то

обычный print не показывает некоторые объекты(символы), например пустые строки, переносы строк, он удобен для пользователя 

# если вывод у pprint не влазит в ширину окна, то его можно увеличить
# когда вывод не влез, это можно понять, что строка перенесена, но у предыдущей строки нет в конце запятой

from pprint import pprint

pprint(result, width=120)       # по умолчание в строке около 80 символов, result - это многоуровневый словарь к примеру

# можно установить глубину вывода, например полезно для словарей, выведет только ключи
pprint(result, depth=1)         # если после ключа к примеру покажет [...] значит там есть данные, которые он не показал, можно увеличить глубину
pprint(result, depth=2)         # например выведет ключи и значения их, если есть еще вложения, то покажет [...]

# pprint выводит на stdout, но бывает нужно красивый вид записать в файл
# тогда можно использовать функцию pformat
from pprint import pprint, pformat
pformat(result, width=120)      # функция pformat возвращает строку которую можно, записать в файл

with open("results.txt", "w") as f:         # записать вывод как у pprint в файл, например хотим красивый лог получить
    f.write(pformat(result, width=120)

# по умолчанию pprint сортирует словарь по ключам, начиная с версии 3.8 можно отключить сортировку, и выводить данные в таком виде в котором они есть
pprint(config_dict, sort_dicts=False)  

==============================================================================================

### РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ ###

# регулярки - это шаблоны, которые используются для поиска подстрок

r" -  raw-строка, правильный тон указывать перед регуляркой это обозначение (хотя и без указания к будет работать, кроме случаев когда надо экранировать спец.символы, например "\")
\  - экранирование специальных символов

# наборы символов
\d - любая цифра
\D - любой символ, кроме цифр
\s - whitespace ( \t\n\r\f\v )                    # \s - пробел, \t - таб, \n - перевод строки, \r - перевод коретки
\S - все, кроме whitespace
\w - любая буква, цифра, или нижнее подчеркивание
\W - все, кроме букв, цифр и нижнего подчеркивания

# Пробел не тоже самое что \s,  \s включает в себя также \t\n\r\f\v, поэтому что писать " " или \s - зависит от ситуации 
# Если мы точно знаем что там пробел, то лучше поставить пробел " ". Если не знаем чем разделение идет, то лучше \s

# символы повторений
*     - ноль или более повторений предшествующего элемента
+     - одно или более повторений предшествующего элемента
?     - ноль или одно повторение предшествующего элемента
{n}   - ровно n повторениЙ предшествующего элемента
{n,m} - от n до m повторениЙ предшествующего элемента
{n,}  - n и более повторениЙ предшествующего элемента,  {,n} - до n повтрений

# специальные символы
.      - любой символ, кроме символа перевода новой строки  # в квадратных скобках точка теряет специальность, там она именно точка 
^      - начало строки
$      - конец строки
[abc]  - любой символ в скобках (в квадратных скобках символы ".", "+" и др. теряют специальность)
[^abc] - любой символ, кроме тех, что в скобках
(abc)  - выражение рассматривается как один элемент (группировка), также используется для запоминания
a|b    - элемент a или b            # aa|bc - воспринимается как: все слева или все справа. 
                                    # Если надо не все, то надо взять в скобки: a(a|b)c

(?P<name_group>...)  # именованная группа, где ... - регулярка, name_group - имя группы
(?:...)              # отключение запоминания группы, , где ... - регулярка


# Пример:
\w\w\w\w\.\w\w\w\w\.\w\w\w\w                   # mac-адрес
\d+                                            # любые цифры/числа, разделенные чем то
\d+\.\d+\.\d+\.\d+  '''или'''  (\d+\.){3}\d+   # IP-адрес
(\d\d)+                                        # числа, состоящие изчетного количества цифр 
(a1)+                                          # a1, a1a1, a1a1a1, ....
\S+ +\S+ +\S+ +\S+ +\w+ +up                    # FastEthernet0/1   10.0.12.1  YES  manual  up    up     - из вывода show_ip_int_br вывести строки со статусом up
^\S+ +\S+                                      # FastEthernet0/1   10.0.12.1
\S+ .+                                         # .+ - "жадные", совпадения до конца нашей строки
[\d.]+   '''или'''   [0-9.]+                   # IP-адрес и другие цыфры
[a-fA-F0-9]                                    # один символ MAC-адреса
([a-fA-F0-9]{4}\.){2}[a-fA-F0-9]{4}            # MAC-адрес
[^.:]                                          # все кроме точки и двоеточия
\w+-?\w+[.:-]\w+-?\w+[.:-]\w+-?\w+             # описать например варианты MAC-адресов ( b07d.47d1.e6a3, b07d:47d1:e6a3, b0-7d-47-d1-e6-a3)
\w+\w-?\w\w[.:-]\w\w-?\w\w[.:-]\w\w-?\w\w      # Тоже самое но понятнее
up|down                                        # совпадения: up или down
\d+|\.                                         # совпадения: цифры или точка 
\S+ +\S+ +\w+ +\w+ +(up|down) +(up|down)       # FastEthernet0/1   10.0.12.1  YES  manual  up    up
(\S+ +){4}(up|down) +(up|down)                 # тоже самое

# * и + жадные, если с точкой
\S+.+up                                       # подразумевается "жадность", так как захватится до последней up в строке

# знак ? отключает жадность 
\S+.+?up                                      # до первого совпадения up сделали

# Пример про жадность
<text line> some text>      # <.*>   --->   <text line> some text>
                            # <.*?>  --->   <text line>

# точка - это любой символ, кроме перевода строки, но можно сделать так что вообще любой символ (поставить флаг "singal line"), тогда весь текст точка захватит а не построчно

# скобки помимо группировки позволяют запоминать группы 
(\S+) +(\S+) +\S+ +\S+ +(up|down)       # запомнили три группы, которые в скобках (для вывода show_ip_int_br это будут группы с номером интерфейса и его адрсесом)
(\S+ +){4}+(up|down)                    # запомнили две группы, в первой группе запомниться только последнее/четвертое повторение 

# Пример, есть адрес 192.168.100.1, применяем следующей regex:
((\d+\.){3}\d+)         # тут 2 группы запомняться
                        # 192.168.100.1  - первая группа, допустим потом ее можем использовать
                        # 100.           - вторая группа, просто к примеру чтобы не писать 3 раза \d+\.

# группы нумеруются по порядку (запоминая также можно отключать)

# есть именованные группы (используется синтаксис в группе ?P<name_group>)
(?P<interface>\S+) +(?P<ip>\S+) +\S+ +\S+ +(up|down)   # сделали именованые группы interface и ip, в коде можем к ним обращаться по имени

# группа без запоминания (используется синтаксис в группе ?:)
(\S+) +(?:\S+) 

----------------------------------

# Модуль re    (регулярные выражения) 

import re

Основные функции модуля re:
1) search       # ищет первое совпадение с шаблоном
2) match        # ищет последовательность в начале строки
3) findall      # ищет все совпадения с шаблоном. Возвращает результирующие строки в виде списка
4) finditer     # ищет все совпадения с шаблоном. Возвращает итератор
5) compile      # компилирует регулярное выражение. К этому объекту затем можно применять все перечисленные функции
6) fullmatch    # вся строка должна соответствовать описанному регулярному выражению

Кроме функций для поиска совпадений, в модуле есть такие функции:
• re.sub        #  для замены в строках
• re.split      # для разделения строки на части

--------------------------------------

1.) функция search

# функция search - находит только одно совпадение (первое), если совпадение нет то, вернет None

re.search(pattern, string, flags=0)         # результат работы функции объект match
# дальше к возвращенному объекту можем применять его методы и т.д.

int_line = "MTU 1500 bytes, BW 10000 Kbit"

m = re.search(r"\d+", int_line)             # под регулярку попадают числа, функция search найдет первое совпадение

m  --- >  # <re.Match object; span=(26, 40), match='1500'>

m.group()                                   # метод group() покажет что совпало --- > 1500
m.string                                    # исходная строка (переменная)

# если в регулярке применяем группы то можем их возвращать
log2 = "Sep  3 12:49:15: %SW_MACFLAP: Host 0011.2fef.191c in vlan 159 is flapping between port Gi2/0/1 and port Gi1/0/1"
m = re.search(r"Host (\S+)", log2)
m.group()  '''или''' m.group(0)             # "Host 0011.2fef.191c"
m.group(1)                                  # "0011.2fef.191c"  -  совпадение первой группы (\S+)

m = re.search(r"Host (\S+) .+ port (\S+) and port (\S+)", log2)
m.group()                                   # "Host 0011.2fef.191c in vlan 159 is flapping between port Gi2/0/1 and port Gi1/0/1"
m.group(1)                                  # "0011.2fef.191c"
m.group(2)                                  # "Gi2/0/1"
m.group(3)                                  # "Gi1/0/1"
m.group(1, 2, 3)                            # ("0011.2fef.191c", "Gi2/0/1", "Gi1/0/1")
m.group(2, 1, 2)                            # при необходимости можно так
m.groups()                                  # ("0011.2fef.191c", "Gi2/0/1", "Gi1/0/1") 

# Если знаем что после слова Host идет MAC-адрес, то лучше описать MAC-адрес так (\S+), чем ((\w+\.){2}\w+) 
# в регулярке лучше вставлять окружающие слова
# можно обращаться к группе по индексу или имени

m = re.search(r"Host (?P<MAC>\S+) .+ port (?:\S+) and port (\S+)", log2)
m.group("MAC")      # "0011.2fef.191c"
m.group(1)          # "Gi1/0/1"             - порт Gi2/0/1 я отключил группу ?:

m = re.search(r"Host (?P<MAC>\S+) .+ port (?P<port1>\S+) and port (?P<port2>\S+)", log2)

# получить словарь, где ключи - это имена групп, значения - это выражения

m.groupdict()       # {'MAC': '0011.2fef.191c', 'port1': 'Gi2/0/1', 'port2': 'Gi1/0/1'}

# если с группой нет совпадение, то вернется в этой группе None
# если в регулярке есть "или" | между группами, то посмотреть какая группа совпала можно адрибутом lastgroup  (без (), это не метод)

m.lastgroup
m.lastindex     # если группа не именована, то можно индекс совпавшей группы получать

# если регулярка вернула такой результат:  m --- >
<re.Match object; span=(26, 40), match='15.0.15.1'>

# то чтобы найти позиции в строке можно методами start и end
m.start()       # 26
m.end()         # 40
m.span()        # (26, 40)


# регулярку можно разбивать на строки, как и литералы строк (для удобства и подписи комментариев)
regex = r"(\S+) +([\d.]+|unassigned) +\S+ +\w+ +(up|down) +(up|down)"

regex = (
    r"(\S+) +"                      # Интерфейс
    r"([\d.]+|unassigned) +"        # IP-адрес
    r"\S+ +\w+ +"                   # пропускаем
    r"(up|down) +(up|down)"         # статусы
)


-------------------------------------

2.) функция match и fullmatch - очень похожи на search, описание выше          # поэтому не рассматриваем

-------------------------------------

3.) функция finditer  -  ищет все непересекающиеся совпадения в шаблоне, 
                         возвращает итератор с объектами Match 

# вывод надо передавать весь, а не построчно

# пример в файле regex_example_finditer_sh_ip_int_br.py  (а также в файле regex_example_finditer_sh_cdp_nei_detail.py)

regex = r"(\S+) +(\S+) +\w+ +\w+ +(up|down) +(up|down)"
with open("sh_ip_int_br.txt") as f:
    content = f.read()                                   # применяем finditer ко всему файлу
    all_match = re.finditer(regex, content)            
    for match in all_match:                              # т.к finditer итератор, то надо перебирать в цикле, чтобы вывести              
        print(match.groups())
    # results = [match.groups() for match in all_match]  # тоже самое с помощью генератора списка, будет список кортежей
    # pprint(results)    
        
# пример для нахождения совпадений в одной строке (вывести все vlan)
line = "switchport trunk allowed vlan 1,2,3,10,20,30,100,400"
m_all = re.finditer(r"\d+", line)
for m in m_all:                   # т.к finditer итератор, то надо перебирать в цикле, чтобы вывести
    print(m.group())              # 1 2 3 10 20 30 100 400  -  результат

# удобнее для такого простого примера использовать findall (о ней чуть ниже)
re.findall(r"\d+", line)          # [1, 2, 3, 10, 20, 30, 100, 400]  -  получим список и в цикле перебирать не надо
                                  # даже если если несколько строк с allowed vlan будет, все найдет

# Флаги (полезные)
a.) re.DOTALL (re.S)       # 'точка' в регулярном выражении будет включать перевод строки \n   (regex101.com флаг single line)
b.) re.MULTILINE (re.M)    # чтобы символ начала строки '^' и конда строки '$' работал для отдельной строки в регулярке и не всего вывода 
c.) re.IGNORECASE (re.I)   # любой регистр слов в тексте (замедляет обработку регулярки)
d.) re.ASCII (re.A)        # если знаем что у нас только ascii символы (если нет кирилицы к примеру) то ускоряет работу регулярки

re.finditer(regex, output, re.DOTALL)
re.finditer(regex, output, re.DOTALL | re.IGNORECASE| re.M)   # флаги пишем через pipe


-------------------------------------

4.) функция findall  -  ищет все непересекающиеся совпадения в шаблоне, возвращает:
- список строк, которые описаны в регулярке, если в нем нет групп
- список строк, которые совпали в регулярке, если в нем одна группа
- список кортежей, которые находятся строки, которые совпали с выражением в группе, есди групп несколько

# Примеры
output = """
Mac Address Table
-----------------------------------
Vlan Mac Address     Type     Ports
---- -----------     -------- -----
10   0001.9629.9b02  DYNAMIC  Gig0/1
20   00d0.975c.d003  DYNAMIC  Gig0/2
...
"""
regex =r"\d+ +\S+ +\w+ +\S+"        # без групп или с группами без запоминая будет вывод такой:
re.findall(regex, output)           # ["10   0001.9629.9b02  DYNAMIC  Gig0/1", "20   00d0.975c.d003  DYNAMIC  Gig0/2"]

regex =r"(\d+) +\S+ +\w+ +\S+"      # с группой будет вывод совсем другой                  
re.findall(regex, output)           # ["10", "20"]   -  список строк с vlan

regex =r"(\d+) +(\S+) +\w+ +\S+"    # с несколькими группами будет список кортежей             
re.findall(regex, output)           # [("10", "0001.9629.9b02"), ("20", "00d0.975c.d003")]

regex =r"(?^<vlan>\d+) +(?^<mac>\S+) +\w+ +(?^<interface>\S+)"

-------------------------------------

5.) функция compile  -  возможность заранее скомпелировать регулярные выражения, а затем использовать его
                        полезно когда регулярку часто используем в скрипте (для удобства и ускорения)
# Лучше привыкать к конструкции с compile (чем просто re)

regex = re.compile(<наша регулярка>, флаги)     # такая конструкция, флаги переносим в регулярку и применяем compile
regex.<метод>()                                 # будут доступны методы re (groups, finditer, findall, match и т.д.)

# Пример (подробно в файле regex_example_compile_sh_cdp_nei_detail.py)
regex = re.compile(r"Device ID: (?P<device>\S+)", re.DOTALL | re.ASCII)
match_all = regex.finditer(output)              # сдесь только текст передаем над которым надо регулярку применить


-------------------------------------

re.split  -  функция рабтает аналогично методу split в строках,
             но тут можно использовать регулярки, а значит разделять строку по более сложным условиям

ospf_route = 'O 10.0.24.0/24 [110/41] via 10.0.13.3, 3d18h, FastEthernet0/0'

ospf_route.split()                  # обычный split разделит по пробелам
re.split(r"\s+", ospf_route)        # тоже самое c re.split  (за исключнием что обычный split еще в начале и в конце удаляет спец.символы, т.е. делает strip)

re.split(r"[ ,]+", ospf_route)      # разделить или по пробелу или по запятой (в выводе исчезнут запятые)
re.split(r"[ ,\[\]]+", ospf_route)  # исчезнут еще и квадратные скобки

# еще пример
line = "R1           Eth 0/1         122           R S I           2811       Eth 0/0"
re.split(r"  +", line)      # разделить по минимум двум пробелам, очень удобно и проще чем обычный split
                            # ["R1", "Eth 0/1", "122", "R S I", "2811", "Eth 0/0"]

-------------------------------------

re.sub  -  функция работает аналогично методу replace в строках, 
           использование регулярок, значит более сложные условия замены

ospf_route = 'O 10.0.24.0/24 [110/41] via 10.0.13.3, 3d18h, FastEthernet0/0'
re.sub(r"[,\[\]via]", "", ospf_route)      # заменить запятую, скобки, via на пустую строку

# Пример с повторением захваченного результата (запоминание групп)
output = """
Mac Address Table
-----------------------------------
Vlan Mac Address     Type     Ports
---- -----------     -------- -----
 10   0001.9629.9b02  DYNAMIC  Gig0/1
 20   00d0.975c.d003  DYNAMIC  Gig0/2
...
"""
re.sub(r" (\d+) ", r"Vlan \1",output)                   # заменить ' 10' на 'Vlan 10', ' 20' на 'Vlan 20'

# Еще пример с повторением захваченного результата

re.sub(r"(\w+)+\.(\w+)+\.(\w+)", r"\1:\2:\3", output)   # изменить MAC-адреса '0001.9629.9b02' на  '0001:9629:9b02'

# !!! В целом группы можно в выводе менять местами

-------------------------------------

# Пример найти повторяющиеся числа в строке (например из вывода show ip bgp найти строки, в которых повторяются AS (prepend в маршруте))
"""
!!!  Очень полезный пример
"""
bgp = "<вывод show ip bgp>"
for line in bgp.split("\n"):
    m = re.search(r"(\d+) \1", line)               # \1 - значит повторять первую группу, т.е группу (\d+). #  (r"(\d+) \1 \1".line) - 3 повторения
    m = re.search(r"(?P<as>\d+) (?P=as)", line)    # вариант с именованой группой
    if m:                                          # так можно указать любую группу \2 \3, если несколько групп в выражении
        print(line)

# поиск подряд повторяющихся строк
re.search(r"(.+)\n\1", line)

# найти строку которая повторяется в файле несколько раз
re.search(r"(^.+$).*\1", line, re.MULTILINE | re.DOTALL)        

"""
С помощью словаря можно легок найти повторяющиеся строки в файле, например

lines = {}                          # делаем пустой словарь 
with open("CAM_table.txt") as f:    # перебираем строки в файле
    for line in f:
        line = line.strip()         
        if line not in lines:       # если строки нет в словаре, то записываем ее в качестве ключа и ставим значение 0
            lines[line] = 0
        else:                       # если строка есть в словаре, то записываем ее в качестве ключа и ставим значение 1
            lines[line] += 1        # дальше теперь, где в словаре значения 1 можем вывести эти строки повторяющиеся
"""

# Небольшой пример про применение форматирование к нашим группам
with open("CAM_table.txt") as f:
    for line in f:
        m = re.search(r"(\d+) +(\S+) +\w+ +(\S+)", line)
        if m:
            print("{:10}{:30}{}".format(*m.groups()))           # вывод значений наших 3-х групп отформатируют/выровняет 
                                                                # не знаю зачем тут звездочка *m.group (надо проверить), наверно тут ** 2 звездочки должно быть


==============================================================================================

### UNICODE ###

на Linux и Mac по умолчанию кодировка UTF-8

В Python 2 концепции:

1) Текст (строки) - неизменяемая последовательность Unicode-символов. 
Для хранения этих символов используется тип строка (str)
2) Данные (байты) - неизменяемая последовательность байтов. 
Для хранения используется тип bytes. 
Избежать работы с байтами нам нельзя, т.к. при при работе с сетью и файлами чаще всего результат возвращается в байтах.

Для записи символов в байты нужна договоренность как они будут выглядеть. 

Стандарт ASCII - описывает соответствие между символом и его числовым кодом, изначально 127 символов было (кирилицы в нем нет).
(Например: А - 0х41, шестнадцатиричный формат, один символ - 1 байт)
 
127 символов - это половина возможностей от байта (256 можно закодировать одним байтом).
Дальше появились другие стандарты(ISO 8859-1, Windows CP1252 и др.), в них добавилсь новые символы других языков.
Потом стало не хватать одно байта чтобы закодировать все символы (всех языков). 

Поэтому придумали стандарт Unicode (144697 символов на 2021 год) - каждому символу придумали порядковый номер(код), (всего возможно 1114112 кодов)
Стандарт также определяет кодировку (способ представления кода символа в байтах)
Примеры символов: U-1F383, U-2615 (также у каждого символа есть наименование), записывается в 16-ричном формате, иногда в десятичном

Кодировка UTF-8:
1) Позволяет хранить символы Unicode
2) Использует переменное количество байт (от 1 до 4), (в первых битах указывается количество байт)
3) Символы ASCII обозначаются такими же кодами 

-------------------------------------------------
байтовая строка - обозначается впереди --> b'.....

s = "привет"
s.encode()        # b'\xd0\xbf\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82',  байтовая строка нашей переменной
len(s.encode())   # 12, так как каждая буква кирилицы это 2 байта, то количество байт нашей переменной 12
len(s)            # 6, это количество символов

ASCII символы в Python показываются в байтовых строках обычными символами, так как Python автоматически их интерпретирует и показывает нормально
s = "hello"
s.encode()        # b'hello'    - отобразит нормально, т.к. в строке только ASCII-символы, но на самом деле там байтовая строка

result = subproccess.run("ls", stdout=subprocess.PIPE)
result.stdout     # b'.....  - вернется список каталогов, но в виде байтовой строки

# посмотреть тип переменной
type("s")            # str
type(result.stdout)  # bytes 
type(b"s")           # bytes, сделать байтовый вывод (просто для примера)

# посмотреть порядковый номер
ord("Ы")    # 1067
ord("s")    # 115

# посмотреть символ по номеру
chr(115)    # 's'

# сделать байтовую строку (например в некоторых модулях надо передать байтовую строку)
b"sh clock\n"        # так только можно делать с ASCII символы
b"привет"            # будет ошибка, т.к. символов этих нет в ASCII таблице

# Конвертация между строкой и байтами
encode  -   есть только у строк
decode  -   есть только у байт

unicode.encode() --> bytes  
bytes.decode()   --> unicode

"мир".encode()                         # b'\xd0\xbc\xd0\xb8\xd1\x80', превратить в байты  (или к примеру: s.encode()
b'\xd0\xbc\xd0\xb8\xd1\x80'.decode()   # 'мир', превратить в строку   (или к примеру: result.stdout.decode()

# строку можно указать с помощью кодов unicode
"\u0041\u0042\u0043"     # 'ABC'
"\u0041".encode()        # b'A'

# можно иногда встретить такую последовательность кодов, т.к. некоторые модули так отображают не ASCII-символы 

# указать кодировку
s.encode()            # по умолчанию используется utf-8
s.encode("utf-16") 
s.encode("ascii")     # если в строке s содержится символы не из ascii, будет ошибка с указанием какие символы не удалось закодировать
 
s_bytes = s.encode("utf-8")
s_bytes.decode("utf-8")     # раскодировать байты в строку

!!!
# Если мы что-то не можем декодировать к примеру, то будет ошибка(исключение) и ничего не выведется,
# но можем обработать такие ошибки, указав параметр error, по умолчанию error="strict"
s_bytes.decode("ascii",error="replace")      # replace просто заменит непонятные байты на что-то другое (какие-нибудь ромбики)
s.encode("ascii",error="replace")            # replace неизвестные символы заменит знаками вопрос b'????'

--------------------------

import sys
sys.getdefaultencoding()     # посмотреть кодировку по умолчанию в Python (это utf-8)

f = open("text.txt")                        # файл по умолчанию открываеся и декодируется кодировкой utf-8
f = open("text.txt", "rb")                  # rb - открыть в байтовом режиме
f = open("text.txt", "r", encoding="UTF-8") # явно указать с какой кодировкой открыть файл 

Это нужно, т.к. в Windows по умолчанию другая кодировка

# Лучше сразу указать как декодировать (например декодироать вывод subproccess)
# будет возвращаться сразу строка, а не байты
result = subproccess.run("ls", stdout=subprocess.PIPE, encoding="UTF-8")

# Оборудование может поддерживать что угодно (например ASCII или UTF-8)
# UTF-8 перекрывает ASCII, можно его всегда использовать при отправке команд и считывании результата

!!!
# При работе всегда надо работать со строками, конвертацию из байт (decode) всегда делаем в первую очередь
# Если надо отправить куда-то байты, всегда делаем encode в последнюю очередь 

============================================================================================
============================================================================================

### Сериализация данных ###

# Это сохранеие данных в каком то формате. Чаще всего, это сохранение в каком-то структуированном формате.

1) CSV-формат (табличные данные).
    - любую таблицу можно экспортировать в формат CSV и обрабатывать её с помощью Python
2) JSON-формат (комбинация списка, словарей и строк)
    - можно описать конфигурацию через этот формат, управляющий софт может возвращать данные в JSON 
    - используется для взаимодействия по API
3) YAML-формат (текстовый формат для записи данных, более приятен/прост)
    - удобно использовать для описания параметров (настройки различных объектов: IP-адреса, VLAN и др.)
    - знание формата YAML пригодится при использовании Ansible сценариев

- XML-формат (не рассматриваем)
- Базы данных (самостоятельно посмотреть про sqllite, рано или поздно пригодится) 

Для каждого из этих форматов в Python есть модуль, который существенно упрощает работу с ними.

----------------------------------------------------------

# CSV-формат

# Пример Файла:
hostname,vendor,model,location
sw1,Cisco,3750,London
sw3,Cisco,3650,"Liverpool, City"
....
# В простом случае можно делать split по запятой, но не всегда такие простые случае, иногда значение может быть в кавычках или еще что-нибудь
# поэтому есть модуль для работы с CSV

# использование csv.reader для чтения из файла
import csv
with open ("sw_data.csv") as f:
    reader = csv.reader(f)         # reader - это итератор (лениво генерирует строки из файла), поэтому перебираем в цикле
    for line in reader:
        print(line)                # каждая строка, это список вида ['sw3', 'Cisco', '3650' ,'Liverpool, City']

with open ("sw_data.csv") as f:
    reader = list(csv.reader(f))   # если файл небольшой, то с помощью list можем все считать, получим спсиок списков

headers = reader[0]                # заголовки  ['hostname', 'vendor', 'model', 'location']
reader[1:]                         # все остальные значение (список списков)

# Функция next (используется в основном для получения заголовков)  
with open ("sw_data.csv") as f:    
    reader = csv.reader(f)
    headers = next(reader)                    # записать заголовки в переменную headers
    for line in reader:                       # с остальным что-нибудь сделать, но уже в цикле строки с заголовками не будет
        host, vendor, model, location = line  # распаковка переменных
        print(model)                          # # 3750 3650 ...

# использование csv.DictReader  (делает из каждой строки файла словарик)
with open ("sw_data.csv") as f:    
    reader = csv.DictReader(f)               
    for line in reader:                     
        print(line)              # {'hostname': 'sw1', 'vendor': 'Cisco', 'model': '3750', 'location': 'London'}
        print(line["model"])     # 3750 3650 ...
      # print(dict(line))        # Если python ниже 3.7, то там словарь неупорядоченный (OrderedDict), нужно применить dict, чтобы упорядочить


# Запись в csv-файл

data = [['hostname', 'vendor', 'model', 'location'],
        ['sw1', 'Cisco', '3750', 'London, Best str'],
        ['sw2', 'Cisco', '3850', 'Liverpool, Better str']]

with open ("results.csv", "w") as f: 
    wr = csv.writer(f)               # применяем csv.writer для записи
    for line in data:         
        wr.wtiterow(line)            # записываем в файл наши списки
                                     # значения с запятыми будет записано в файл в кавычках "London, Best str"

wr = csv.writer(f, quoting=csv.QUOTE_ALL)   # QUOTE_ALL - все значения записывать в кавычках
                                            # QUOTE_MINIMAL - по умолчанию, кавычки будут там где есть запятые в значении
                                            # QUOTE_NONE - вообще не ставить кавычки
                                            # QUOTE_NONNUMERIC - все в кавычках кроме чисел

# запись из словаря в файл csv

data = [
    {'hostname': 'sw1', 'location': 'London', 'model': '3750','vendor': 'Cisco'}
    {'hostname': 'sw2', 'location': 'Liverpool', 'model': '3850', 'vendor': 'Cisco'}
]

with open ("results.csv", "w") as f:
    wr = csv.DictWriter(f, fieldnames="hostname location model vendor".split())   # в fieldnames указываем ключи, можно менять местами, тогда и файле столбцы поменяются местами
    wr.writeheaders()                                                             # записать сами заголовкм в файл
    for line in data:             
        wr.wtiterow(line)               

# fieldnames=list(data[0].keys()) - можно так указать заголовки
# Если в fieldnames какой-нибудь заголовок (ключ) не включить, то будет ошибка
# Если в fieldnames добавить лишний заголовок (ключ), то этот столбец (поле) запишется, но будет пустым

# Использование другого разделителя

with open ("sw_data2.csv") as f:    
    reader = csv.reader(f, delimiter=";")       # считать из файла, где ипользуется разделитель точка с запятой ";"
    for line in reader:                     
        print(line)  
        
with open ("results.csv", "w") as f:
    wr = csv.DictWriter(f, fieldnames="hostname location model vendor".split(), delimiter=";")  # записать в файл с разделителем ";"
    for line in data:             
        wr.wtiterow(line) 

# В Windows есть особенность, надо всегда указывать newline="" при открытии файла
with open ("results.csv", "w", newline="") as f:
    writer = csv.writer(dect)
    
----------------------------------------------------------

# JSON-формат

# формат используется для хранения данных, похож на Python, не понимает кортежи только
# также используется для работы с API

# Пример json файла

{
    "access": [
        "switchport mode access",
        "switchport access vlan",
        "spanning-tree portfast",
        "spanning-tree bpduguard enable"
    ],
    "trunk": [
        "switchport trunk encapsulation dot1q",
        "switchport mode trunk",
        "switchport trunk native vlan 999",
        "switchport trunk allowed vlan"
    ]
}

import json

# читать данные из файла (json.load)
with open("sw_templates.json") as f:
    data = json.load(f)                         # переменная будеь содержать словарь в нашем случае

# записать данные в файл (dump.load)
with open("sw_templates_new.json", "w") as f:   
    json.dump(data, f)                          # запись в файл будет сплошная (без отступов), плохо читать визуально

# запись с отступами, параметр indent указывает количество отступов 
with open("sw_templates_new.json", "w") as f:   
    json.dump(data, f, indent=2)                # запись в файл будет с отступами (визуально красиво), (indent=5, если хотим побольше отступов)

# записать данные в файл
with open("sw_templates_new.json", "w") as f:   
    json.dump(data, f)

# если мы получили строку json-формата, то надо применять json.loads, например:
with open("sw_templates.json") as f:
    data_str = f.read()               # допустим получили строку откуда-то, в которой json данные
    json.loads(data_str)              # применяем loads и получим из строки словарь в нашем случае

# также можно сделать строку в формате json с помощью dumps.load
json.dums(data)         #  делаем строку в формате json из нашего словаря, потом допустим через API ее передадим куда-нибудь

# Конвертация данных Python в JSON    (при конвертации структура данных маленько меняется)
dict        <--->  object
list, tuple <--->  array                # из списка в JSON будет конвертация в список в Pyton (не в кортеж)
str         <--->  string
int, float  <--->  number
True        <--->  true
False       <--->  false
None        <--->  null  

# В JSON ключи могут быть только строками, поэтому если в Python ключи числа, то при конвертации они станут строками. 
# Если в Python ключи другого типа (например кортеж), то будет ошибка, но можно применить ключ skipkeys, чтобы игнорировать данные которые непонимает JSON
with open("sw_templates_new.json", "w") as f:
    json.dump(data, f, indent=4, skipkeys=True)     # строки из словаря с непонятными для JSON данными будут игнорированы и не запишутся в файл         

# Много случаев, когда JSON-файл содержит кучу вложенности словарей, работа с такими словарями(списками)несложная но требует много практики, 
# например, считали json-файл и начинаем анализироавть и перебирать в цикле необходимые ключи
for i in data["configuration"]:
    print(i)                                          # смотрим, какое значение, далее перебираем вложенные словари
for i in data["configuration"]["interfaces"]:
    print(i)                                          # смотрим, и так далее перебираем вложенности, пока не найдем нужные нам значения
for i in data["configuration"]["interfaces"]:
    print(i["address"])      

# Или так перебирать вложенность
for key, value in data.items():                 # перебираем словарь
    #print(key)
    #pprint(value)
    if type(value) == dict:
        for key_n, value_n in value.items():    # если есть вложенные словарь, то его перебираем и т.д. пока не найдем нужные значения из файла
            print(value_n)
    if type(value) == list:
        for i in value:
            print(i)

-------------------------------------------------------------------

# API - программный интерфейс (используется для программ и скриптов, а не для человека)
# По сути API состоит из множества ссылок, по которым обратившись мы можем получить нужную информацию в формате JSON

### Пример работы с GitHub через API ### 

# для работы надо логин и токен (раньше всместо токена был пароль), через токен позволяет делать права на что-нибудь (например только на репозиторий)

pip install requests            # сторонний простой модуль для работы с API  (но в Python есть и встроенный модуль для работы с API, не сказали какой)

import requests

username = "nemetsky"
token = "..."                   # token = os.environ.get("GITHUB_TOKEN") - в уроке так делали, т.к. все токен прописывали куда-то в окружение

r = requests.get('https://api.github.com/user', auth=(username, token))         # запрос информации о пользователе

# если r возвращает <Response [200]>, то все ОК

r.text                    # строка котораю получили из API по нашему запросу
json.loads(r.text)        # делаем словарь из строки которую получили  

# или можно так словарь сразу получить
data = r.json()                           

# Если хотим записать данные в json-файл, то надо учитывать что не ASCII-символы (например кирилица) запишутся кодами (Ничего страшного, т.к. если считать потом, то Python разпознает коды)
# Но можем применить параметр ensure_ascii, который скажет что если символы не знаешь, то запиши как есть (будет визуально теперь все понятно)
with open("github_api", "w") as f:
    json.dump(data, f, indent=4, ensure_ascii=False )


# Запрос информации о репозиториях
r = requests.get('https://api.github.com/user/repos', auth=(username, token))         

repos = r.json()    # словарь с информацией по репозиториям
                    # внутри могут быть еще ссылки в значениях некоторых ключей

r = requests.get(repos[0]["owner"]["followers_url"], auth=(username, token))        # обратились по ссылки, которая записана у первого репозитория repos[0] во подсловаре followers_url

# И так далее обращаясь по ссылкам и записывая информацию в словарь мы вынимаем получаем нужную информацию
# В документации по API GitHub можно почитать как с ним работать (например вместо get можем применить delete, чтобы удалить репозиторий)

# Обычно для работы с API с каким то оборудованием существуют специальные модули для Python для облегчения/автоматизации работы с этим оборудованием
# (например, чтобы обращаться не по ссылкам, а по каким то объектам, использовать какие то методы и т.п.)
# Модули эти пишет или сам вендор пишет или сторонние разработчики. Например для работы с API GitHub есть модуль PyGithub.
# (Искать в поисковике например Cisco API Python)

----------------------------------------------------------

# YAML-формат

# текстовый формат для записи данных, более восприятен человеком, чем JSON, испольщуют для написания сценариев (например, Ansible)
# также как в python в YAML используются отступы (пробелы)

# Список имеет 2 вида записей:
1) [switchport mode access, switchport access vlan, switchport nonegotiate]     # в скобках без кавычек
2) - switchport mode access                                                     # каждая строка должна начинаться с '- ' (минуса и пробела)
   - switchport access vlan
   - switchport nonegotiate

# Словарь имеет 2 вида записей:
1) { vlan: 100, name: IT }
2) vlan: 100
   name: IT

# Строку можно писать в кавычках, но можно и без кавычек, если нет спец. символов в строке
command: "sh interface | include Queueing strategy:"

# Комбинация элементов
access:                                 # словарь в котором 2 ключа, значения у которых списки
- switchport mode access
- switchport access vlan
- spanning-tree bpduguard enable
trunk:
- switchport trunk encapsulation dot1q
- switchport mode trunk
- switchport trunk native vlan 999

- BS: 1550                              # список словарей
  IT: 791
  name: Liverpool
- BS: 1510
  IT: 793
  name: Bristol

# установка модуля для работы с yaml
pip install pyyaml

# запись в файл
import yaml
data = [
    {'BS': 1550, 'IT': 791, 'name': 'Liverpool'},
    {'BS': 1510, 'IT': 793, 'name': 'Bristol'}
]
with open("test_data.yaml", "w") as f:
    yaml.dump(data, f)

# чтение из файла
with open('info.yaml') as f:
    templates = yaml.load(f)            # load - в основном использовали раньше, но просто load может загружать любые структуры данных, что-то лишнее (небезопасно)
    templates = yaml.safe_load(f)       # safe_load  -  загружает только базовые структуры данных (лучше его использовать)
    templates = yaml.full_load(f)       # full_load  -  загружает все объекты

# YAML понимает все объекты Python d отличие от JSON, но некоторые выглядят странно 
# например кортеж (100,200) в значении словаря будет выглядеть типа:
: !!pytnon/tuple
- 100
- 200

# Можно из JSON файла читать (конвертировать) в YAML, и наоборот
# Если запутался в синтаксис YAML, то можно создать в Python данные и записать в YAML


============================================================================================
============================================================================================

### ПОДКЛЮЧЕНИЕ К ОБОРУДОВАНИЮ ###    
    
Модули для подключения SSH/Telnet
- pexpect
- telnetlib
- paramiko
- netmiko
- scrapli

# Передача пароля
- запрос пароль при старте скрипта и считывать ввод пользователя (например модуль getpass)
- хранить логин и пароль в файле (небезопасно)
- можно также через переменные окружения, логин/пароль живет на время сессии (потенциально может быть небезопасно)
- можно запрашивать пароль испоьзую input (видно какие символы вводит пользователь)
- используя модуль, который хранит логин/пароль где-то (не рассматриваем в курсе)
- Есть полезный модуль click, который может перебирать методы ввода пароля (немного о нем Лекция 16_1, время 11-00)

# getpass  -  модуль запрашивает пароль, и не отображает его ввод

import getpass
password = getpass.getpass()    # запрос пароля
print(password)                 # <пароль> - будет видно пароль в открытом виде

# переменные окружения

export SSH_USER=user                         # в командной строке выполняется, записать логин и пароль в переменные окружения
export SSH_PASSWORD=userpass

import os
username = os.environ.get('SSH_USER')        # считать логин и пароль в переменные скрипта
password = os.environ.get('SSH_PASSWORD')


----------------------------------------------------------

### Модуль pexpect ###

# может подключаться куда угодно по telnet, ssh, ftp. 
# у самого модуля нет встроенных клиентов, он использует системные программы
# это низкоуровневый модуль, он не понимает что работает с сетевым оборудованием, ему пофиг
# в отличие от специальных модулей для сетевого оборудования, может работать с любым оборудованием любого вендора
# ожидает определенный вывод (приглашение, запрос пароля и т.д), получив вывод отправляет команды и так далее
# не работает на Windows
# методов у модуля много, смотреть в документации, тут рассматриваем основные

pip install pexpect
import pexpect

# функция run (похожая на subprocess)  
output = pexpect.run('ls -ls')  # run позволяет вызвать какую-нибудь программу и вернуть ее вывод
print(output)

# функция spawn
s = pexpect.spawn('ssh user@10.1.1.1')  # spawn позволяет взаимодействовать с вызванной программой, отправляя данные и ожидая ответы
                                        # вмсето ssh можно telnet использовать
s.expect('Password:')                   # ожидаем такой ответ 'Password:' с оборудования, если результат команды индекс "0" значит совпал ожидаемый ответ (со строкой 0)
s.sendline(password)                    # sendline - отправить строку/данные, также добавиться автоматически перевод строки. (И покажет сколько байт отправлено, если результат sendline записать в переменную, но это не зачем делать)
                                        # send     - метод отправит без перевода строки !!!
s.expect('>')                           # s.expect('R1[>#]')  - или так можно с регуляркой [>#] ожидать ответ, также уточнять можно R1
                                        # expect считывает информацию из буфера до указанного символа '>', если считалось то буфер очищается.
                                        # Если не совпало с ответом, то будет исключение и !!! там видно подробно будет, что было в буфере (какой вывод и т.д.)
s.sendline('enable')
s.sendline(enable_pass) 
s.expect('#')
s.sendline("terminal length 0")
s.expect('#')
s.sendline("show clock")
s.expect('#')
s.before                                # получить вывод из буфера до той строки, что мы указали в expect '#'. (Вывод будет до первого совпадения с ожидаемым ответом '#'). 
                                        # т.е если отправить 2 команды подряд, то s.before будет содержать только вывод первой команды. 
                                        # Если еще раз сделать before, то получим второй вывод, так как он буфере еще есть (мы его не считывали)
                                        # поэтому после sendline надо делать сразу expect лучше, чтобы сдвига не было
                                        # если в буфере ничего нет, то будет исключение по таймауту
s.pexpect(["R2", "R1"])                 # можно так указать списком ожидаемый ответ, pexpect вернет 0 или 1 (это номер строки из списка с которым совпало), дальше можно делать if
s.pexpect(["R2", "R3", pexpect.TIMEOUT])# можно указать исключение в списке (чтобы не использовать конструкцию try/except)
                                        # ["R2", "R1"] - т.е. ждет ответ или R1 или R2 (ищет в буфере), если нет в буфере, то вернется индекс 2, а в списке под индексом 2 указали исключение сразу (не надо нам try/except писать в коде)
s.close                                 # закрыть сессию

# Как обработать исключение с помощью try/exept
try:
    s.sendline('sh clock')
    s.expect('#')                       # например в выводе не нашел '#', там '>'
except pexpect.TIMEOUT as error:
    print(error)

s.after                                 # очень редко применяется, покажет часть вывода, это если мы в expect указали что-то из ожидаемого вывода нашей команды, s.expect('Sep 21'), after покажет 'Sep 21', но если регулярка будет, то покажет что по нее попадет в выводе дальше  
output = ssh.before + ssh.after         # '+ ssh.after' - чтобы в конце вывода не обрезалась решетка после имени устройства 

s.sendline("show ip int bri")
s.before     
# вывод before - это одна байтовая строка b'
# строку надо декодировать (decode) либо при подключении указывать кодировку enconing
# строки в выводе с сетевого оборудования разделяются \r\n, поэтому лучше сразу заменить \r\n на \n методом replace

# все это можно в цикле
for ip in devices_ip:
    print("Connection to device {}".format(ip))
    s = pexpect.spawn('ssh {}@{}'.format(user,ip))
    s = sendline...
    s = expect...
    ...

s.send(" ")     # метод send отправляет что-то, в нашем примере пробел, без перевода строки 

# обязательно в скриптах надо добавлять паузы
!!! Примеры с пояснениями в файлах example_pexpect_show.py, example_pexpect_configure.py, example_pexpect_paging.py

----------------------------------------------------------

### Модуль telnetlib ###

# Входит в стандартную библиотеку, это реализация клиента telnet, не привязан к оборудованию
# похож не pexpect, но основное отличие - требует передачи байтовой строки, а не обычной (если используем ASCII символы то достачно добавлять b"")
# вместо expect и sendline, ипользуются методы read_until и write (read_until - ситает до строки)
# pexpect если читает до какого-то символа, то он его не включает в вывод, а telnetlib включает в вывод !!!!!!!!!!!

import telnetlib

r1 = telnetlib.Telnet("10.1.1.1")
r1.read_until(b"Username")                    # везде при чтении и отправке указываем байты \b
r1.write(b"cisco\n")                          # r1.write(user + b'\n')
r1.read_until(b"Password")                    
r1.write(b"cisco\n")                          
r1.read_until(b">")                           
t.write(b"enable\n")                          
t.read_until(b"Password")                     
r1.write(b"cisco\n")                          
r1.read_until(b"#", timeout=2)                # лучше везде указывать для read_until таймаут, 
                                              # так как если в выводе не будет ожидаемой строки, то не будет исключения как в pexpect, и будем ждать долго            
                                              # с одной стороны хорошо, с другой не очень, вернеется то что было в буфере
r1.write(b"terminal length 0\n")               
r1.write(b"show run\n")                        
time.sleep(3)                                 # обязательно делать между write и read_very_eager паузу                          
output = r1.read_very_eager().decode('utf-8') # read_very_eager() - читает в буфере то что есть на данный момент
                                              # .decode('utf-8')  - сразу перевели из байтовой строки в обычную

# метод expect - используется вместо read_until когда требуются регулярки, 
#                ждет список строк которые могут вернуться, 
#                возвращает кортедж вида: (<индекс>, <объект re.Match>, <вывод>), индекс - индекс совпадения из списка,  re.Match - что совпало под нашу регулярку, вывод - байтовая строка
r1.write(b"sh clock\n")
match = r1.expect([b">", b"#"])     

# можно использовать переменные user, password, command - должны быть байтовые строки, т.е. сделать функцию предварительно чтобы перевести в байты

# Пример в файле example_telnetlib.py и у автора (обязательно посмотреть пример)

----------------------------------------------------------

### Модуль paramiko ###

# подключение только по SSH (version 2), поддерживает и Client и Server

pip install paramiko

client = paramiko.SSHClient()                                 # этот класс представляет соединение в SSH-серверу. Выполняет аутентификацию клиента
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # set_missing_host_key_policy не является обязательной, она указывает какую политику использовать, когда выполнятся подключение к серверу, ключ которого неизвестен
                                                              # paramiko.AutoAddPolicy() автоматически добавляет новое имя хоста и ключ в локальный объект HostKeys.

client.connect(hostname="192.168.100.1", username="cisco", password="cisco", look_for_keys=False, allow_agent=False)    # подключение к оборудованию

# look_for_keys - по умолчанию paramiko выполняет аутентификацию по ключам, надо отключать если ключи не используем
# allow_agent - paramiko может подключаться к локальному SSH агенту ОС (если по ключам подключаемся)

ssh = client.invoke_shell()              # Метод invoke_shell позволяет установить интерактивную сессию SSH с сервером.
    
ssh.send("enable\n")                     # Метод send - отправляет указанную строку в сессию и возвращает количество отправленных байт или ноль если сессия закрыта и не удалось отправить команду
ssh.send(enable_pass + "\n")    
time.sleep(1)                            # между send и recv ставим паузу обязательно
ssh.send("terminal length 0\n")     
time.sleep(1)   
ssh.send("sh ip int br\n")               # ssh.send(command + "\n") 
time.sleep(2) 
ssh.settimeout(5)                        # установить таймаут на считывание информации из сессии         
result = ssh.recv(10000).decode("utf-8") # Метод recv получает данные из сессии. В скобках указывается максимальное значение в байтах, которое нужно получить. Этот метод возвращает считанную строку
ssh.close()                              # закрыть сессию


# Примеры в файлах example_paramiko_1_basic.py и example_paramiko_2_read_until.py
# Примеры с вводом команд (config) у автора посмотреть

----------------------------------------------------------

### Модуль netmiko ###

# netmiko - это обертка paramiko, понимает сетевое оборудование, различает вендоров, упрощает "жизнь", на него похож также модуль scrapli (+/- одно и тоже) 
#           умеет также telnet, scp

# netmiko не проверяет есть ли команда уже в конфигурации, он только отправляет команды и получает вывод (также как и модуль scrapli) 
# можно написать отдельную функцию для проверки есть ли такие команды уже (В примерах файл 4_netmiko_check_cfg.py).
                                                          
!!! Более продвинутые модули/инструменты (на уровень выше), которые понимают логику оборудования - это napalm, nornir, ansible (их изучение сложнее и надо проверять поддерживают ли они вашего вендора)

pip install netmiko

import netmiko

# Пример использования
command = sys.argv[1]
user = input("Username: ")
password = getpass.getpass()
enable_pass = getpass.getpass(prompt="Enter enable password: ")
devices_ip = ["192.168.100.1"]
for ip in devices_ip:
    print(f"Подключение к {ip}")                     # параметры подключения указываются в словаре (параметров очень много, смотреть в документации)
    device_params = {"device_type": "cisco_ios",     # device_type - предопределенные значения, которые понимает netmiko ("eltex", "eltex_esr")
                     "host": ip,
                     "username": user,
                     "password": password,
                     "secret": enable_pass}          
    ssh = netmiko.ConnectHandler(**device_params)    # соединение с устройством с нашими параметрами, **device_params - распаковать словарь в ключевые аргументы
    # ssh = netmiko.Netmiko(**device_params)         # можно так подключаться (более новый способ)
    ssh.enable()                                     # вход в режим enable с ключом secret (необязательно)
    result = ssh.send_command(command)               # ssh.send_command - отправка команд show чтобы получить результат, terminal length отправляется по умолчанию
    print(result)


!!! ssh.close, ssh.disconnect()  - ???  # Если не используем контекст with netmiko.ConnectHandler(**device_params) as ssh:   - то походу надо закрывать сессии вручную 

# !!! Посмотреть поддерживаемые "device_type" https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md

# !!! Посмотреть примеры с netmiko, т.к. много чего не рассматриваем https://github.com/ktbyers/netmiko/blob/develop/EXAMPLES.md

# Методы netmiko
send_command            - отправить одну команду (только для команд типа show/display)
send_config_set         - отправить одну или несколько команд конфигурации
send_config_from_file   - отправить команды из файла (внутри используется метод send_config_set)
send_command_timing     - отправить одну команду и подождать вывод на основании таймера

# Пример send_config_set
ssh.send_config_set("logging 10.1.1.1")            # автоматически зайдет в режим конфигурирования если нужно и потом выйдет из него
ssh.send_config_set(["lo0", "description TEST"])   # отправить список команд 

ssh.config_mode()                                                 # зайти в конфиг-режим (чтобы потом например отправлять по одной команде и например считывать информацию и проверять)
ssh.send_config_set("logging 10.1.1.1", exit_config_mode=False)   # отправить команду и не выходить из режима
ssh.exit_config_mode()                                            # выйти из режима конфиг

ssh.find_prompt()         # посмотреть строку приглашения, в каком мы сейчас режиме работаем ( R1# , R1(config)# , и т.д.)
                          # штука полезная, в том плане что ее можно добавлять в вывод в начало, чтобы видно было на каком оборудование сделан вывод
                          
ssh.send_command("sh int descr", strip_command=False, strip_prompt=False)  # не обрезать в выводе саму команду и не обрезать в конце prompt  

# новая фича полезная !!!
ssh.send_config_set("blablabla", error_pattern="%")   # если при отправке команды возникла ошибка, то происходит исключение и останавливается отправка следующих команд (но если предыдущие прошли без ошибки то они не отменяться)

# netmiko умеет парсить вывод
ssh.send_command("sh ip int br", use_textfsm=True)    # в результате получим список словарей (в этом случае с интерфейсами)

# использование telnet
"device_type": "cisco_ios_telnet"       # указать в параметрах подключение по telnet, дальше все как с SSH    

"""
Если мы хотим не отключать paging, то как это сделать можно посмотреть в примере 4_netmiko_more.py
в том примере используются нискоуровневые методы для этих целей: 
- read_until_pattern (читает вывод до чего-то)
- write_channel (ничего не ждет, а просто отправляет команду/символы)
"""
Методы read_until_pattern, write_channel могут пригодится где-нибудь


============================================================================================
============================================================================================

### ОДНОВРЕМЕННОЕ ПОДКЛЮЧЕНИЕ К НЕСКОЛЬКИМ УСТРОЙСТВАМ ### 

concurrent.futures - модуль для параллельного подключения к устройствам

# Три конструкции
1.) паралельные процессы (process - грубо говоря запущенная программа, выделяются ресурсы (память) каждому процессу, у каждого процесса свой GIL, оптимально если задача "завязана" на CPU, зависит от количества ядер CPU)
2.) параллельные потоки (thread - распараллеливание процесса, разделяют ресурсы процесса, выполняются на одном ядре). !!! Рассматриваем только этот метод.
3.) ассинхронный подход (сложный подход, рассматривается в продвинутом курсе)

# Потоки отлично подходят для задач с операциями ввода-вывода (подключение к оборудованию, скачивание файлов, работа с файловой системой).
# На самом неделе потоки - это не совсем параллельное подключение, а попеременное. Во время пауз флаг GIL (Global interpreter lock) передается от одного потока другому.

# оценка времени выполнения скрипта
1.) утилита Linux time
time python <script>.py             # достаточно написать time перед запуском скрипта

2.) модуль datetime

from datetime import datetime
import datetime

start_time = datetime.now()
time.sleep(5)                       # какие-то действия тут (подключения к оборудованию)
print(datetime.now() - start_time)

!!! #  Скрипт netmiko_count_threads.py тестирует и можно вычислить оптимальное количество потоков для себя (в зависимости от количества устройств и ресурсов машины с которой конфигурим оборудование)

# Потоковая безопасность
# код считается потокобезопасным (thread-safe), если он может работать при использовании нескольких потоков
Правила:
1.) не писать в один и тот же ресурс из разных потоков (к примеру не писать в один файл или словарь) (предназначен ли ресурс для многопоточности -- > гуглить по словосочетанию "python write to file from threads" )
2.) избегать коммуникаций между потоками в процессе их работы
3.) делать все максимально просто (принцип KISS "keep it simple, stupid")

Print - не является потокобезопасным, при большом количестве устройств, выводы из устройств могут смешивается в выводе print

-------------------------------------------------------------

# Модуль logging

# В отличии от print модуль logging является потокобезопасным
# logging позволяет настраивать логирование из скрипта
# все сообщения будут выводиться на стандартный поток вывода

import logging

logging.basicConfig(format="%(threadName)s %(name)s %(levelname)s: %(message)s", level=logging.INFO)     # в каждом сообщении будет информация о потоке, имя логера, уровень сообщения и само сообщение     
logging.info("текст или переменная")      # в таком виде применяем вместо print

# '%(threadName)s' - старый синтаксис записи формата, вместо новой конструкции '{}'.format(...)    (рассматриваем его т.к. он часто встречается именно с logging, в книге описан)
# параметры threadName, name, levelname, message и много других есть в описании модуля на сайте
# level=logging.INFO   - сообщения уровня INFO и выше, можно выставить DEBUG тогда будет куча сообщений, для траблшутинга полезно

модули netmiko, paramiko внутри тоже используют модуль logging и как только мы включаем logging.basicConfig мы увидим логи с этих модулей

# установить для модуля netmiko например другой уровень логирования или можно отключить его логирование
logging.getLogger("netmiko").setLevel(logging.WARNING)

-------------------------------------------------------------

# Модуль concurrent.futures

# решает задачу запуска нескольких потоков/процессов и получения из них данных, для этого используются 2 класса:
- ThreadPoolExecutor - для работы с потоками
- ProcessPoolExecutor - для работы с процессами (не рассматриваем)

from concurrent.futures import ThreadPoolExecutor

# Создание объекта Executor
executor = ThreadPoolExecutor(max_workers=5)        # max_workers=5  -  сколько потоков используем 

# Создание объекта Executor через менеджер объектов
with ThreadPoolExecutor(max_workers=5) as executor:

# Методы объекта Executor
shutdown                    # завершение потоков, не используем т.к. работать будем через менеджер объектов 
map                         # запуск функций в разных потоках
submit                      # запуск функций в разных потоках

# Функция должна выполнять одно действие. Например, если необходимо пинговать несколько IP-адресов в разных потоках, надо создать функцию, которая будет пинговать один IP-адрес, 
# а затем запустить эту функцию в разных потоках для разных IP-адресов с помощью concurrent.futures.
# (т.е. надо сделать фунццию для одного действия (сконфигурировать устройство к примеру), и потом эту функцию размножать по потокам)

---------------------------
# Функция map - применение функции к каждому элементу (делаем как бы внутри цикл)
list(map(str, [1,2,3]))       # ["1", "2", "3"]
[str(i) for i in [1,2,3]]     # тоже самое с помощью генератора списка
-----

from operator import add      # функция add работает как "+" :  add(1, 3)  --- >  4

[add(i, j) for i, j in zip([1,2,3], [10,20,30])]   # [11, 22, 33]    --> сложили соответствующие числа из последовательностей и получили новую последовательность
list(map(add, [1,2,3], [10,20,30]))                # тоже самое с помощью map в которую передали функцию add с аргументами в виде списков (последовательности должны быть одного типа и с одинаковым числом элементов (иначе будет обезание))
-----

from itertools import repeat            # repeat - итератор которому передаем элемент и он повторяет его до бесконечности

list(map(add, [1,2,3], repeat(10)))     # [11, 12, 13]  
-----  
---------------------------

# Метод map 

# работает похоже на встроенную функцию map: применяет функцию func к одному или более итерируемых объектов. 
# При этом, каждый вызов функции запускается в отдельном потоке. Метод map возвращает итератор с результатами выполнения функции для каждого элемента итерируемого объекта. 
# Результаты расположены в том же порядке, что и элементы в итерируемом объекте.
map(func, *iterables, timeout=None)

executor = ThreadPoolExecutor(max_workers=2)                 # 2 потока (как только какой-нибудь поток освободится, он выполнил на следующем устройстве функцию)

# выполнение в потоках нашей функции и запись результатов в итератор q
q = executor.map(send_show, devices, repeat("sh clock"))     # применяем метод map к нашей функции и передаем в нашу функцию аргументы по одному (устройство с параметрами из словаря devices и команду (повторяем команду одну и ту же на устройства))  

# q = executor.map(send_show, devices, ["sh clock", "sh ip int bri"])  # в таком виде будут на разные устройства разные команды отправяться 

# q  -  это результат, это итератор, далее его надо перебировать в цикле, чтобы достать информацию, которую он собрал с устройств

for result in q:        # этот цикл будет выполняться с паузой, берем данные из итератора по мере того как на устройстве функция отработала
    print(result)       # !!!  в result будет вывод в том же порядке как мы на устройства отправляли команды / перебирали devices
    


  

