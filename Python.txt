### НЕОБХОДИМО ПОСТАВИТЬ МОДУЛИ ###
pip install pytest pytest-clarity==0.3.0a0 pyyaml tabulate jinja1 textfsm netmiko

https://pythontutor.com/            # Деббагер

==============================================================================================

###  Типы данных: ###
Изменяемые:
 - списки (Lists)
 - словари (Dictionaries)
 - множества (Sets)
 
 Неизменяемые:
 - числа (Numbers)
 - строки (Strings)
 - кортежи (Tuples)
 
 Упорядоченные:
 - списки
 - кортежи
 - строки
 - словари
 
 Неупорядоченные:
 - множества
 
 Есть еще тип Boolean

==============================================================================================

### ЧИСЛА ###

# в python переменные это метки (ссылки)
a = 5
b = a
# то есть переменные a и b это ссылки на одно и тоже значение которое где то хранится в памяти, а не два одинаковых значения
# одинаковые id у них
id(a)
id(b)

# есть отличие от списков, так как переменные это неизменяемые типы данных, а списки изменяемые
# у переменных с одинковым значением от 1 до 254 - id переменных будут с одинаковым значением, 
# а со значением от 255 и выше у каждой переменной (если значения одинаковы, без применения ссылок), то будут разные id
# но если сделать ссылку на число то id буду одинаковым
a = 1000
b = a             # b будет 1000 и id будет одинаковые

round(10/3, 2)    # округлить до двух знаков

10%3              # остаток от деления

# операторы сравнения 
==     # равно
!=     # не равно

# Число записывается без кавычек, может быть float, Например 10.0 
data = "11"
int(data)         # преобразовать в десятичное число 11
int(data, 2)      # говорим что преобразовать из двоичного системы счисления в десятичное число, результат здесь будет 3
bin(255)          # преобразовать из десятичного в двоичное (0b будет начинаться), 0b11111111
hex(255)          # из десячного в шеснадцатиричный (0x будет начинаться), 0xff
int("0x11", 16)   # из 16-ричного значения преброзовать в десятичное, будет 17

# Сразу из 16-ричного в двоичное преобразовать нельзя, через десятичное только
h = "ff"
dec_h = int(h, 16)
bin(dec_h)
# или сразу так
bin(int(h, 16))

#
int(4.5)           # будет 4, округление до меньшего

a, b = 1, 2     # значит a = 1, b = 2  групповое создание переменных

+=    # значит к этому числу прибавить что то, например:
а = 5
а = а + 5 
# или просто
a += 5
# есть также -= ,  *=

# для сложных математических функций есть модуль math
import math

==============================================================================================

### СТРОКИ ###

Кавычки или двойные "" или одинарные '', строку исходную менять нельзя 

# экранирование символов
\'      

# многострочная строка, все скрытые символы включены будут в строку (пробелы, переводы строки)
template = """ 
  interface Tunnel0
   ip address 10.10.10.1 255.255.255.0
   ip mtu 1416
"""

# конкатинация строки 
a = "test" "hello"        # результат -> testhello

# разбить строку на литералы для удобства, а также для случаев с ограничениями на макс.число символов в строке
s = ('Test' 'String')     # TestString
s = ('Test'
'String')                 # TestString

# разбить строку в разные строки
a = ("test\n" "hello\n")

# еще важный пример разбить строку на разные строки (часто пригодится)
template = ( 
  "interface Tunnel0\n"
  " ip address 10.10.10.1 255.255.255.0\n"
  " ip mtu 1416\n"
)
# print(template) - красиво покажет вывод с переводом строк, без лишних пробелов в начале строк

# строке можно обращаться по индексу или делать срез строки
cmd = "interface Gi0/0"
cmd[2]                    # "t"
cmd[-4]                   # "i"  
cmd[0:5]                  # "inter" - последний символ не включается в срезе
cmd[2:]                   # срезать от 2 до конца
cmd[:7]                   # срезать с 0 до до 7
cmd[-7:]                  # срезать от -7 до конца

# можно в индексах использовать переменные, только числа
# срез с шагом
s = "0123456789"
s[0:9:2]                  # "02468"
s[1:9:2]                  # "1357"
s[0:9:3]                  # "036"
s[::3]                    # "0369"
s[::2]                    # "02468"
s[::-1]                   # "9876543210"  - в обратном порядке

# строки можно складывать, отличается от конкатинации, тем что сами переменные объеденяются а не их литералы
а = "hello"
b = "world"
a + b   - >  "helloworld"
print(a + " " + b)

# строку можно умножать (повторение)   !(строку с числом складывать нельзя)
"test" * 2      #  testtest

# количество символов (длина переменной), спецсимволы тоже считаются
len(cmd)        #  15

-----------------------------------------------------

### МЕТОД ###   - это фунцкия прилепленная к конкретному типу данных

cmd = "interface Gi0/0"
cmd.upper()      # "INTERFACE GI0/0"  - то есть метод upper сделал заглывные буквы у переменной cmd

cmd.lower?       # будет подсказка по методу
cmd.<TAB>        # все методы покажет

cmd.swapcase()
cmd.capitalize()

cmd.startswith("interface")    #  true     
cmd.endswith("interface")      #  false     
if cmd.startswith("interface"):
    print("OK") 

cmd.startswith(" interface", 1)          # true, проверить начало строки начиная с индекса 1 (к примеру пропустить пробел)
cmd.startswith(("test", "interface"))    # true, строка начинается или с того или с того

cmd.count("e")                           # 2 раза, посчитать сколько раз встречается подстрока      
 
cmd.find("face")                         # найти подстроку, вернет индекс с которого она начинается, если не найдет то вернет -1

index = cmd.find("face")                 # записали в переменную index индекс с которого начинается подсрока face в строке cmd
cmd[index:]                              # сделали срез в строке

cmd = " switchport mode access"
find_word = "mode"
index = cmd.find(find_word)
cmd[index:index + len(find_word)]        # получим слово "mode" сделав срез

cmd.replace("access", "trunk")                               # заменить подсроку в строке (заменяет все вхождения)
cmd.replace("o", "test", 1)                                  # заменить только первое вхождение
cmd.replace("mode", "").replace("trunk", "access vlan 2")    # удалили "mode" и паравозиком еще раз заменили подстроку)

cmd = "\n\n\tinterface Gi0/0\n\t"
cmd.strip()                       # удалить все спец. символы в начале и в конце строки
cmd.lstrip()                      # удалить все спец. символы в начале строки
cmd.rstrip()                      # удалить все спец. символы в конце строки

s = "[110/25]"
s.strip("[]")                     # 110/25 , удалили конкретные символы в конце и начале

cmd = " switchport trunk allowed vlan 1,2,3,4,5\n"
cmd.split()                       # удалить спец символы и разделить строку на отдельные элементы строки по пробелам
cmd.split()[-2]                   # "vlan" , разбить строку и взять 2-ой с конца элемент

vlan = "1,2,3,4,5"
vlan.split(",")                   # ['1', '2', '3', '4', '5']  - разделить на элементы по запятой
ip = "10.1.1.1"
ip.split(".")                     # ['10', '1', '1', '1']  - разделить на элементы по точке

-----------------------------------------------------

### ФОРМАТИРОВАНИЕ СТРОК ###   -  подстановка значений в шаблон переменной, используются скобки {}

cmd = "interface Gi0/{}"
cmd.format(10)                                  # interface Gi0/10

template = """                                  # можно и с replace заменить но это некрасиво и неправльно будет
  interface Tunnel{}
   ip address {}
   ip mtu 1416
"""
template.format(0, "10.1.1.1 255.255.255.0")    # подстановка значений по порядку

template = """                                  # можно в формате индексы проставить, если не попорядку подставлять значения, лучше так как можно одно значение несколько раз подставить
  interface Tunnel{1}
   ip address {0}
   ip mtu 1416
"""
template.format("10.1.1.1 255.255.255.0", 0)    

template = """                                  # можно в формате имена использовать, более понятно и удобнее, также можно несколько раз передавать одно и тоже значение в шаблон
  interface Tunnel{tun_num}
   ip address {ip_addr}
   ip mtu 1416
"""
template.format(ip_addr="10.1.1.1 255.255.255.0", tun_num=0)    

output = "{} {} {}\n"*2
output.format("Fa0/1", "10.1.1.1", "255.255.255.0", "Fa0/15", "10.200.1.1", "255.255.255.0")     # при отображении этих двух строк будет сдвиг

output = "{:10}{:20}{}\n"*2                     # выравнивание, задать ширину значения/столбца с запасом, тогда при отображении строк сдвига не будет
output = "{:<10}{:>20}{}\n"*2                   # выравнивание < по левой стороне, > по правой стороне

template ="{:b} {:b} {:b} {:b}"                 # конвертировать в двоичный формат
template.format(10, 1, 100, 168)
template = "{:08b} {:08b} {:08b} {:08b}"        # перевести в двоичный формат и заполнить нулями до восьми символов (08)
template = "{0:<9}{1:<9}{2:<9}{3:<9}\n{0:08b} {1:08b} {2:08b} {3:08b}"        # вывести адрес в десятичном и двоичном виде и выровнять

-----------------------------------------------------

### F-СТРОКИ ###  - форматирование строк, нет разделения между шаблоном и данными (в циклах удобнее работать)

intf = "Gi0/0"
f"interface {intf}"                   # получим "interface Gi0/0"

cmd = "switchport trunk allowed vlan"
vlan = "1,2,3,4"
f"{cmd} {vlan}"                       # получим объединение строк, также как: cmd + " " + vlan
f"{cmd.upper()} {vlan}"               # плюс также в том, что в f-строке можно использовать методы в переменной

oct1, oct2, oct3, oct4 = 10, 1, 100, 168 
template = f"{oct1:<9}{oct2:<9}{oct3:<9}{oct4:<9}\n{oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}"   # тоже самое форматирование через ф-строку (выведет в двоичном и десятичном форате Ip-адрес)

-----------------------------------------------------

### СПИСОК (list) ###

# последовательность любых элементов, разделенных запятой в квадратных скобках,  в отличие от строк это изменяемый тип данных

list1 = [10, 20, 77, "word"]          # могут быть необязательно однотипные данные в списке
list2 = [                             # для удобства красоты можно столбиком делать список
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]

vlan = "1, 2, 3, 4"
vlan.split(",")         # ["1", "2", "3", "4"]  получить список строк из строки по разделителю запятой

list("test")            # ["t", "e", "s", "t"]  функция list из строки делает список символов

vlans = [10, 100, 101, 200, 201, 202]
vlans[0]                # 10    первый элемент списка, возвращает число
vlans[3]                # 200   четвертый элемент списка
vlans[-1]               # 202   первый с конда элемент списка
vlans[1:4]              # [100, 101, 200]   сделать срез по списку, возвращает список
vlans[3:]               # [200, 201, 202] 
vlans[:4]               # [10, 100, 101, 200] 
vlans[3] = 1200         # изменить элемент под индексом 3 

# СПИСОК СПИСКОВ

vlans = [[10,20,30],[100,200,300],[1000,2000,3000]]
vlans[1]                # [100,200,300]
vlans[1][-1]            # 300

# или через промежуточную переменную
list0 = vlans[1]
list0[-1]               # 300

vlans[1][-1] = 400      # изменить элемент во вложенном списке
interfaces[0][1][1]     # можно список списков разобрать на символы

len(vlans)              # посчитать количество элементов в списке
set(vlans)              # превратит в множество и удалит дубликаты

sorted(vlans)           # сортировака списка, если есть вложенность, то сортирует списки по первому элементу списка, возвращает новый превращает в список
                        # можно по алфавиту сортировать, учитывается регистр, можно в обратном порядке сортировать
                        # числа и строки сортируются по разному, если к примеру сортируем vlan то лучше их превратить в числа предварительно
                        # строки можно сравнивать (сравнение идет по юникод коду символов по порядку)

# МЕТОДЫ РАБОТЫ СО СПИСКАМИ

# функция sorted работает с разными типами данных и возвращает новый список чисел или строк к примеру
result = sorted(vlans)
print(result)

# метод sotr работает только со списками и сортирует тот же самый список и по умолчанию результат не выводит на print (выводит NONE)
vlans.sort()            # отсортирует список но ничего не выведет (NONE)
print(vlans)            # так выведет на экран

vlans.reverse()         # сделает список наоборот

vlans.count(10)         # посчитать сколько 10 в списке
vlans.append(500)       # добавить в конец списка элемент 500, можно создать пустой список и в него добавлять: vlans = []
                        # добавить можно по одному элементу только
vlans.append([100,200]) # можно в список добавить список, но только один

# суммирование списков
vlans1 = [10,20,30,40]
vlans2 = [100,200,300]
vlans1.extend(vlans2)           # прибавить элементы списка vlans2 в список vlan1
vlans1.extend([5,55])           # тоже добавить в список

all_vlans = vlans1 + vlans2     # второй способ суммирования списков, будет новый список в отличие от extend

# метод join - разделитель, применяется для строк или списка строк (если есть список чисел, то их надо преобразовать в спиcок строк сначала)

vlans_str = ["1", "2", "3"]
"".join(vlans_str)              # '123'
",".join(vlans_str)             # '1,2,3'
" = ".join(vlans_str)           # '1 = 2 = 3'

# если есть список строк разделенных например \n, то можно преобразовать в строку с разделителями
access = [
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]
"\n".join(access)               # 'switchport mode access\nswitchport access vlan 20\nspanning-tree portfast'

print("\n".join(access))        # switchport mode access
                                # switchport access vlan 20
                                # spanning-tree portfast

# можно обратно строку в список перевести
data = "\n".join(access)
data.split("\n")

# pop - взять элемент из списка по индексу и удалить его из списка, только один элемент может удалить, элемент который удаляет можно присвоить переменной
vlans = [10,100,101,200,201,202]
vlans.pop()                     # 202   - по умолчанию удаляет последний элемент мз списка
vlans.pop(-1)                   # 201
vlans.pop(0)                    # 10

# remove удаляет значение (только одно), и ничего не возвращает (нельзя записать в переменную) (удалять несколько значений надо через циклы)
vlans.remove(100)               # удалит из списка элемент со значением 100, если есть несколько элементов, то удалит первый с таким значением

# ниже можно тоже самое сделать через pop, только одной командой
a = vlans[-1]
vlans.remove(a)

vlans.index(201)                # вернет индекс под которым этот элемент

# insert вставляет элемент в определенное место в списке
vlans.insert(1, 15)             # вставит число 15 после первого элемента, остальные индексы сместит

-----------------------------------------------------

# !!! В Python переменные это ссылки (метки) на данные
vlans1 = [1, 2, 3]
vlans2 = vlans1                 # vlan2 будет ссылаться на туже область памяти как и vlans1
vlans1.append(100)              # значение 100 добавиться и в список vlans1 в список vlans2  

# убедиться можно посмотря на что ссылаются переменные (на одну и ту же ечейку памяти)
id(vlans1) 
id(vlans2)

# можно делать копии списков, чтобы у списков были разные ячейки памяти
vlans2 =vlans1.copy()

# или через срез создать копию
vlans2 = vlans1[:]

==============================================================================================

### СЛОВАРИ ###

# 2 вида записи словаря
london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
london = {
    'id': 1,
    'name': 'London',
    'user_vlan': 1010,
    'mngmt_vlan': 99,
    'to_name': None,             # none - нет значения
    'port': 'G1/0/11'
}

# 'name': 'London1'  - ключ: значение,

# доступ к значению по ключу, но по значению ключ найти нельзя (для этого словарь не преднасзначен) (только методом перебора)  
# ключ должен быть неизменяемого типа (число, строка, кортеж), значение может быть любого типа

london["name"]                   # обращение к элементу
value = london["name"]           

london["vendor"] = "Eltex"       # изменить значения для ключа Vendor
london["ip"] = "10.1.1.1"        # добавить в словарь новую пару ключ-значение

# может быть словарь в словаре (очень распространенный вариант)
london_co = {
    'r1': {
        'hostname': 'london_r1',
        'vendor': 'Cisco',
        'model': '4451',
    },
    'r2': {
        'hostname': 'london_r2',
        'vendor': 'Cisco',
        'model': '3925',
    },
}

# модуль pprint используется для красивого отображения сложных словарей
from pprint import pprint
pprint(london_co)

london_co["r2"]["model"]            # "3925"  - обращение к подсловарю 
london_co["r2"]["model"] = "7206"   # изменить модель R2

len(london_co)                      # количество ключей
sorted(london_co["r1"])             # отсортировать в словаре r1, сортировка только по ключам работает

del london["name"]                  # удалить ключ name

london.clear()                      # обнулить/очистить словарь
# или
london = {}

# Копия словаря методом указания что один словарь равен другому означает, что копируются ключи словаря, а значения это ссылки на другой словарь
# лучше копировать методом copy
london2 = london.copy()

# Метод get
london.get("nam")                   # если такого ключа нет, то ошибки не будет, а просто вернется None
london.get("nam", "No Key")         # можно вернуть любое свое значения, если такого ключа нет, например No Key

"vendor" in london                  # узнать если ключ vendor в словаре london (вернет либо True либо false)

london.keys()                       # получить все ключи
london.values()                     # получить все значения
london.items()                      # получить все пары ключ-значение

london_co["r1"].keys()              # получим список ключей подсловаря

# keys, values, items - специальные типы данных которые являются ссылками на словари, меняются вместе со словарем
keys_1 = london.keys()              # нельзя потом обратиться к keys_1[0], но можно сделать следующее
keys_1 = list(london.keys())        # получим список ключей, можно сделать keys[0]
values_1 = list(london.values())    # получим список значений
items_1 = list(london.items())      # получим список пар в виде кортежа

# метод update - можно суммировать/объеденять словари
r1 = {'name': 'London', 'vendor': 'Cisco'}
r1_new = {'ip': '10.1.1.1', 'vendor': 'Eltex'}
r1.update(r1_new)                                           # в словарь r1 добавится ключ ip и измениться значение ключа vendor

# или так без промежуточной переменной:
r1.update({'ip': '10.1.1.1', 'vendor': 'Eltex'})

# Метод pop
london.pop("name")                                          # взять ключ name и удалить его из словаря
# или можно было сделать так вместо pop:
value = london["name"]
del london["name"]

# Списки подходят под однородные данные, в отличие от словарей
# можно из списков сделать словарь, например
access_1 = ['sw mode access', 'sw access vlan 10']
trunk_1 = ['sw mode trunk', 'sw trunk allowed vlan 10,20']
sw_command = {'access': access_1, 'trunk' = trunk_1}        # access_1 и trunk_1 это ссылки на списки, если изменим переменные то и словарь изменится

# !Некоторые методы нельзя делать прямо в значении в словаре, например 
d = {1: [1,2,3].append(4)}                       # вернет None
# надо делать через промежуточные переменные
d = {1: [1,2,3]}
d[1].append(4)

d[1].insert(2,100)                               #  d -- > {1: [1, 2, 100, 3, 4]}    вставить элемент 100 в значение списка ключа 1 после 2-го элемента

-----------------------------------------------------

# вариант создания словаря с DICT если все значения являются строками
r1 = dict(model="4451", ios="15.4")         # конструктор dict позволяет не использовать кавычки в ключах и скобки

# еще вариат с dict если есть список кортежей
r1 = dict([('model', '4451'), ('ios', '15.4')])

# dict.fromkeys()   - сделать заготовку словаря, если знаешь ключи но нет значений еще, чтобы в него потом к примеру записывать
d_keys = ['hostname', 'vendor', 'ip']
r1 = dict.fromkeys(d_keys)                  #  r1 -->  {'hostname': None 'vendor': None, 'ip': None}

# ПРИМЕР, создать словарь который будет подсчитывать кол-во Vlan на коммутаторах, 
sw1_vlans = [1, 2, 3, 4]                    # список vlan на sw1
sw2_vlans = [1, 3, 4]                       # список vlan на sw2
hostnames = ['sw1', 'sw2']                  # создаем список коммутаторов
all_vlans = dict.fromkeys(hostnames, 0)     # создали словарь с дефолтным значениями 0, -> {'sw1': 0, 'sw2': 0} 
all_vlans['sw1'] += len(sw1_vlans)          # записываем в словарь количество vlan на sw1   ( +=  значит   all_vlans['sw1'] = all_vlans['sw1']) + len(sw1_vlans)
all_vlans['sw2'] += len(sw2_vlans)          # записываем в словарь количество vlan на sw2
print(all_vlans)                            # {'sw1': 4, 'sw2': 3}

==============================================================================================

### КОРТЕЖ (tuple) ###

# Это можно сказать неизменяемый упорядоченный список, вместо [] используется ()
# Кортеж дает возможность в ключах словаря писать несколько элементов (так как список в ключах словаря использовать нельзя)
# Также используется когда данные мы получаем извне (например: из БД, из csv-файла)

data = ('sw1', '10.1.1.1', 'Cisco IOS')
data.count('sw1')                   # 1
data.index('Cisco IOS')             # 2

tuple1 = tuple()                    # пустой кортеж (очень редко, но бывает нужен), обязательно tuple надо указать для пустого кортежа
tuple2 = ('password',)              # кортеж из одного элемента (иногда нужен), обязательно запятая в конце

# Кортеж из списка, tuple - превратить в кортеж
list_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']
tuple_keys = tuple(list_keys)       # ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

tuple_keys[0]                       # 'hostname'
tuple_keys[1:]                      # ('location', 'vendor', 'model', 'ios', 'ip')  - срез

tuple('test')                       # ('t', 'e', 's', 't')                       

# добвить элемент в кортеж
vlans = (1,2,3)
vlans_new = vlans + (4,) + (5,6)    # (1,2,3,4,5,6)

# сортировка
sorted(tuple_keys)                  # сортирует и возвращает список 

==============================================================================================

### МНОЖЕСТВО (set) ###

# Это изменяемый неупорядоченный тип данных, содержатся только уникальные элементы
# используются фигурные скобки, но в отличие от словаря нет пары ключ-значение

vlans = {10,20,30,10,20,1}          # {1,10,20,30}   - уникальные элементы, но необязательно по порядку
names = {'sw1', 'sw2', 'rt1'}

# пример есть список, надо получить список уникальных элементов из него
vlans = [1,2,3,4,3,1,2,1]
list(set(vlans))                    # [1,2,3,4]  

set1.add(5)                         # добавить элемент в множество
set1.remove(4)                      # удалить элемент из множества
set1.update([50,60])                # добавить несколько элементов

# операции с множеством
vlans1 = {1,2,3,4,5}
vlans2 = {3,4,5,6,7}
vlans1.intersection(vlans2)         # {3,4,5} - какие vlan общие
vlans1.difference(vlans2)           # {1,2} - какие vlan есть в множестве vlans1 но нет в vlans2
vlans1.union(vlans2)                # {1,2,3,4,5,6,7} - объединение множеств
vlans1 & vlans2                     # тоже самое что intersection
vlans1 - vlans2                     # тоже самое что difference
vlans1 | vlans2                     # тоже самое что union
vlans1.symmetric_difference(vlans2) # {1,2,6,7} - что уникального в обоих множествах 

set1 = {}                           # это будет пустой словарь
set1 = set{}                        # это будет пустое множество, так создается со словом set

==============================================================================================

### БУЛЕВЫ ЗНАЧЕНИЯ (Boolean) ###

None
True
False
# регистр имеет значение, если с маленькой буквы то уже будет переменные

s = 'hello'
s.startswith('h')       # True
                        
vlans = [1,2,3,4]       
5 in vlans              # False

# Ложные значения:
- 0
- None
- пустая строка
- пустой объект

# Остальные истинные значения
- любое ненулевое число
- любая непустая строка
- любой непустой объект

# bool - проверяет истинное значение или ложное
bool(vlans)            # True
bool(2)                # True
bool([])               # False
bool(0)                # False

if vlans:              # если не равно 0
# или тоже самое
if len(vlans) != 0:

==============================================================================================

### ПРЕОБРАЗОВНИЕ ТИПОВ ###

int()                  # преобразование строки в число
bin()                  # дяситичное число в двоичное
hex()                  # дяситичное число в 16-ричное
list()                 # преобразует аргумент в список 
set()                  # преобразует аргумент в множество уникальных элементов
tuple()                # преобразует аргумент в кортеж
str()                  # преобразует аргумент в строку

### ПРОВЕРКА ТИПОВ ###

# есть куча методов для строк is...
isdigit()              # проверить состоит ли строка из одних цифр
isalpha()              # проверить состоит ли строка из одних букв
"a10".isdigit()        # False    (если будет True то можно будет строку к примеру в число превратить)  
"abc".isalpha()        # True

type()                 # функция проверяет тип перменной
type(aaa)              # Если aaa - строка, то вернет str, если aaa - список то вернет list и т.д
if type('aaa') == str: # потом применяем в условии

==============================================================================================

### СОЗДАНИЕ БАЗОВЫХ СКРИПТОВ ###

Чтобы сделатьфайл исполняемым в linux надо в первой строке написать
#!/usr/bin/env python
либо
#!/usr/bin/env python3

# после этого дать права на запуск файла
chmod +x access_template_exec.py

# и запускать след. образом
./access_template_exec.py

-----------------------------------------------------

### Передача аргументов скрипту с помощью argv ###

# в argv все передается как строки, если нужно передать как число то надо конвертировать int

# первый способ
import sys
vlan = sys.argv[1]                  # говорим что Vlan получить из аргумента с индексом 1, (индекс 0 - это всегда имя скрипта)
                
print(sys.argv)                     # напечать аргументы, которые мы передаем в скрипт при запуске скрипта
 
# второй способ
from sys import argv
vlan = argv[1]

#  запуск скрипта
python access_template_argv.py 5       

-----------------------------------------------------

### Передача аргументов с помощью input ###

# Функция input - передать информацию скрипту по запросу, аргументы передаются в input тоже как строки

vlan = input("Введи номер Vlan: ")
intf = input("Введи номер интерфейса: ")

input("Нажмите Enter для продолжения")     # сделать паузу в скрипте

==============================================================================================

### ОПЕРАТОРЫ ###
if / elif / else
'''
Принцип как у ACL, если условия выполняется (возвращает true) проверка останавливается, 
elif может быть несколько веток в одном блоке, if только один в блоке, следующий if с таким же оступом будет считаться другим блоком.
можно делать вложенный if (с помощью отступов)
Обязательно только условие if (elif и else необязательно)
'''

if a == 10:
    print('a равно 10')
elif a < 10:
    print('a меньше 10')
else:
    print('a больше 10')

list_to_test = [1, 2, 3]                
if list_to_test:                           #  можно так сократить
    print("В списке есть объекты")
# или так можно сделать
if len(list_to_test) != 0:
    print("В списке есть объекты")

# можно писать в одну строку но это плохой тон, только если одно условие if используется
# или редкий пример (трехнарное выражение)
result = True if len(s) > 5 else False

-----------------------------------------------------

# Оператор in (входит ли элемент куда-то, в списке, в множестве, в кортеже. В словаре проверяет ключи. В строке есть ли подстрока)
if 'access' in line
    print(line)
    
'Fast' in 'FastEthernet'                   # True

string1 = "switchport mode trunk"       
'trunk' in string1                         # True
'trunk' not in string1                     # False
'access' in string1 or 'trunk' in string1  # True

vlan = [10, 20, 30, 40]
50 in vlan                                 # False

r1 = {
    'IOS': '15.4',
    'IP': '10.255.0.1',
    'hostname': 'london_r1',
}
'IOS' in r1 and 10 in vlan                 # можно применять операторы and, or, not
('IOS' in r1) and (10 in vlan)             # или так

# Есть приоритность операторов, посмотреть в документации на сайте можно
# Всегда можно посмотреть что нового в новой версии Python (What is new in Python 3.9)

# Если с оператором and все значения истина, то возвращается последенее значение элемента, а не true/false
"line1" and "line2" and "line3"            # line3  вернется

# Если с оператором and есть ложное значение, то возвращается первое ложное значение элемента, а не true/false
"line1" and "" and "line3"                 # ""  вернется

# Удобро предварительно проверять с оператором and последовательно условия, например:
a = '10'
a.isdigit() and int(а) > 5                 # т.е. если строка 'a' состоит из чисел, то вычисляем 'a' и проверям на условие. 
                                           # а если 'a' это не число, а к примеру a = "a", то вернется False и дальше проверяться не будет (а значит и ошибки не будет в выражение int(а))    

# Если с оператором or есть истиные значения, то возвращается первое истиное значение, а не true/false
"line1" or ""                              # "line1"    вернется

# Если с оператором or все значения ложные, то возвращается последнее ложное значение
"" or False or 0                           # 0  вернется

& - and                                    # можно писать символами но принято писать словами 

-----------------------------------------------------

# ПРИМЕР КАК СО СЛОВАРЕМ МОЖНО УПРОСТИТЬ КОНСРУКЦИЮ IF 

cfg = input("Введите что надо настроить: ")
if cfg == "access":
    print("access_cfg")
elif cfg == "trunk":
    print("trunk_cfg")
elif cfg == "vpn":
    print("vpn_cfg")
else:
    print("такой конфигураии нет")

# проще со словарем
cfg = input("Введите что надо настроить: ")    
cfg_dict = {
    "access": "access_cfg",
    "trunk": "trunk_cfg",
    "vpn": "vpn_cfg"
}
if cfg in cfg_dict:
    print(cfg_dict[cfg])
else
    print("такой конфигураии нет")

==============================================================================================

### ЦИКЛЫ ###

Цикл for

# Применение: перебор строк, словаря, списка, функция range(), любой итерируемый объект
# for работает в списке со значениями а не с индексами, в словаре перебирает ключи

for letter in 'Test string':
    print (letter)                         # перебрать буквы и вывести на печать
                                           # letter произвольное название переменной
vlans_list = [1,2,3,4]
vlans_str = []
for each_vlan in vlans_list:
    print(each_vlan * 100)                 # перебрать список vlan и что-то сделать с каждым vlan
    vlan_str.append(str(each_vlan))        # превращаем vlan из числа в строку и добавляем в другой список
print(vlan_str)   

# Пример: из строки с IP сделать список чисел из октетов IP
ip = "192.168.100.1"
octets = ip.split(".")  
octets_int = []
for octet in octets:
    octets_int.append(int(octet))          # [192, 168, 100, 1]

# Функция range - особый тип данных, создается по мере необходимости

range(1,5)                                 # диапазон чисел от 1 до 5 не включая 5
list(range(1, 5))                          # будет список [1, 2, 3, 4]

for number in range(11):                   # диапазон от 0 до 10
    print(f"interface Gi0/{number}")       # выведет список интерфейсов
    print(f" description vlan_{number}")

# for со словарем
r1 = {
    'IOS': '15.4',
    'IP': '10.255.0.1',
    'hostname': 'london_r1',
}
for key in r1:
    print(key, r1[key])                    # перебор словаря и вывод ключей, а также и значений ключей
    
for key in r1:
    print(f"{key:20}{r1[key]}")            # вывести красиво с выравниваем первого столбца

# Можно также вывести ключ-значение из словаря с помощью РАСПАКОВКИ ПЕРЕМЕННЫХ:

for item in r1.items():                    # r1.items() - отдельный тип, список кортежей
    print(item)                            # выведем кортежи ключ-значение, 
    key, value = item                      # распаковка item
    print(key, value)                      # печатаем ключ-значение

# Или проще
for key, value in r1.items():
    print(key,value)                       # вывод такой же как и без распоковки, 
                                           # но удобно тем, что есть 2 переменных (ключ и значение) теперь и можно с ними что-то делать

-----------------------------------------------------                            
# Вложенные циклы for

commands = [
    'switchport mode access',
    'switchport access vlan 10',
    'spanning-tree portfast',
    'spanning-tree bpduguard enable']
fast_int = ['0/1','0/3','0/4','0/7','0/9','0/10','0/11']

for intf in fast_int:              # создаем для каждого интерфейса конфигурацию
    print(f"interface {intf}")
    for cmd in commands:           # вместо вложенного цикла можно было также сделать join переменной commands по переводу строки, но с циклом проще
        print(cmd)         

# с условием цикл, подставляем из словаря интерфейс и назначаем соответсвующий vlan, а также другие команды

commands = [
    'switchport mode access',
    'spanning-tree portfast',
    'spanning-tree bpduguard enable']
access = {'0/12': 10, '0/14': 11, '0/16': 17, '0/17': 150}

for intf in access:
    print(f"interface {intf}")
    vlan = access[intf]
    for cmd in commands:
        print(cmd)
    print(f"switchport access vlan {vlan}")
         
# или с распоковкой
for intf, vlan in access.items():
    print(f"interface {intf}")
    for cmd in commands:
        if cmd.endswith("vlan"):
            print(f" {cmd} {vlan}")
        else: 
            print(f" {cmd}")

-----------------------------------------------------

Цикл while 

# если есть условие, но в отличие от if после выполнения условия возвращаемся в начало цикла

a = 5
while a > 0:
    print(a)
    a = a - 1       # a -= 1

vlans = [10, 20, 30, 40]
i = 0
while i < len(vlans):
    print(vlans[i])
    i += 1
    
# или с for удобнее
for vl in vlans:
    print(vl)

# !!! Пример с while - с паролем пользователя в отдельном файле  !!!

У циклов for и while есть бывает конструкция else, но это редко используется
 
-----------------------------------------------------

Оператор break  -  прерывание цикла (используется в for и while), относится только к ближайшему циклу

while True:                 # Значит бесконечный цикл
    .....
    break

-----------------------------------------------------

Оператор continue - возвращает в начало цикла

for num in range(5):
    if num == 3:
        continue
    else:
        print(num)          # выведет на печать все числа кроме 3

-----------------------------------------------------

Оператор pass  -  ничего не делаем в этом месте, временная заглушка, для того чтобы писать дальше код 
# к примеру мы не знаем что в условии писать пока, указываем pass и ошибки не будет (в else писать pass бесмысленно, можно else убрать)

==============================================================================================

### РАБОТА С ИСКЛЮЧЕНИЯМИ ### 
try / except / else / finally

input_1 = input("Введите число: ")
num1 = int(input_1)                         # Если ввели не число, то в этом месте будет Исключение ValueError (определенная ошибка) и код прервется
                                            # значит сначала делаем проверку
if input_1.strip().isdigit():               # удаляем спец.символы в конце и начале, и провереяем что эта введенная строка состоит из чисел, а потом только переводим ее в число
    num1 = int(input_1)
    print("Ок")
else:
    print("Надо вводить только числа")

# В документации на фунцкиям (методы) есть описание Исключений (какие ошибки возникают если что то неправильно сделали или написали)
# Простой способ посмотреть какое исключение появляется, специально предварительно в ipython к примеру воспроизвести его

Конструкция try / except  -  позволяет перехватывать исключения

input_1 = input("Введите число 1: ")
input_2 = input("Введите число 2: ")
try:
    num1 = int(input_1)
    num2 = int(input_2)
    print(num1/num2)                       # для примера еще одного исключения
except ValueError:                         # обрабатываем ситуацию когда введено не число, ошибки не будет, а сделали перехват исключения и предупреждаем
    print("надо вводить только числа")
except ZeroDivisionError:                  # обрабатываем ситуацию, когда может быть деление на 0, т.е. можем несколько исключений (ошибок) перехватывать
    print("возникла ошибка, на ноль делить нельзя")
    
else:                                      # Может указать else, если except у нас не отработал (не было исключений-ошибок)
    print(num1 * num2)                     # что-то можем делать, еlse нужен чтобы мы могли что-то с этими переменными сделать, если надо
                                           # если были бы исключения, то переменным бы ничего не присвоилось и без else мы бы получили ошибку
finally:                                   # что-то в конце сделать, редко применяется, можно без него обойтись
    print("!!!")                           

# в except можно не указывать конкретное исключение, но это плохая практика

# Можно except объединять
except (ValueError, ZeroDivisionError):
    print("надо вводить только числа и число 2 не должно быть равно 0")

# можно вывести на экран какая ошибка если несколько исключений
except (ValueError, ZeroDivisionError) as error:
    print(error)
    print("надо вводить только числа и число 2 не должно быть равно 0")
                                           
# Пример для чего нужны исключения
# Если мы подключаемся к множеству оборудования и на каком то возникла ошибка, то на остальное оборудование надо продолжить подключаться

ip_list = ["10.1.1.1", "10.1.1.2", "10.1.1.3"]
for ip in ip_list:
    print(f"Подключаюсь на {ip}")
    try:
        connect(...)                                             # будто подключаемся к оборудованию
    except TimeoutError:
        print(f" оборудование {ip} не доступно по таймауту")
    except AuthenticationError:
        print("Логин или пароль неправильный")
    print(f"{ip} отработало")

# Генерация исключений, просто пример
try
    if ip == "10.1.1.1"
        raise ValueError("При подключении возникла ошибка")      # сгенерировать в этом мемте исключение 
    except ValueError as error:
        print(f" оборудование {ip} не доступно по таймауту")
        print(error)

==============================================================================================


























