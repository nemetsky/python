### НЕОБХОДИМО ПОСТАВИТЬ МОДУЛИ ###
pip install pytest pytest-clarity==0.3.0a0 pyyaml tabulate jinja1 textfsm netmiko

# Типы данных:
Изменяемые:
 - списки (Lists)
 - словари (Dictionaries)
 - множества (Sets)
 
 Неизменяемые:
 - числа (Numbers)
 - строки (Strings)
 - кортежи (Tuples)
 
 Упорядоченные:
 - списки
 - кортежи
 - строки
 - словари
 
 Неупорядоченные:
 - множества
 
 Есть еще тип Boolean

-----------------------------------------------------

ЧИСЛА

# в python переменные это метки (ссылки)
a = 5
b = a
# то есть переменные a и b это ссылки на одно и тоже значение которое где то хранится в памяти, а не два одинаковых значения
# одинаковые id у них
id(a)
id(b)
# есть отличие от списков, так как переменные это неизменяемые типы данных, а списки изменяемые
# у переменных с одинковым значением от 1 до 256 id переменных будут с одинаковым значением, 
# а со значением от 255 и выше у каждой переменной (если значения одинаковы, без применения ссылок), то будут разные id
# но если сделать ссылку на число то id буду одинаковым
a = 1000
b = a       # b будет 1000 и id будет одинаковые

round(10/3, 2)    # округлить до двух знаков

10%3    # остаток от деления

# операторы сравнения 
==     # равно
!=     # не равно

# Число записывается без кавычек, может быть float, Например 10.0 
data = "11"
int(data)     # преобразовать в десятичное число 11
int(data, 2)  # говорим что преобразовать из двоичного системы счисления в десятичное число, результат здесь будет 3
bin(255)      # преобразовать из десятичного в двоичное (0b будет начинаться), 0b11111111
hex(255)      # из десячного в шеснадцатиричный (0x будет начинаться), 0xff
int("0x11", 16) # из 16-ричного значения преброзовать в десятичное, будет 17

# Сразу из 16-ричного в двоичное преобразовать нельзя, через десятичное только
h = "ff"
dec_h = int(h, 16)
bin(dec_h)
# или
bin(int(h, 16))
#
int(4.5)  # будет 4, округление до меньшего

a, b = 1, 2     # значит a = 1, b = 2  групповое создание переменных

+=    # значит к этому числу прибавить что то, например:
а = 5
а = а + 5 
# или просто
a += 5
# есть также -= ,  *=

# для сложных математических функций есть модуль math
import math

-----------------------------------------------------

СТРОКИ

Кавычки или двойные "" или одинарные '', строку исходную менять нельзя 
# экранирование символов
\'  
# многострочная строка, все скрытые символы включены будут в строку (пробелы, переводы строки)
template = """ 
  interface Tunnel0
   ip address 10.10.10.1 255.255.255.0
   ip mtu 1416
"""
# конкатинация строки 
a = "test" "hello"    # результат -> testhello
# разбить строку в разные строки
a = ("test\n" "hello\n")
# еще важный пример разбить строку на разные строки (часто пригодится)
template = ( 
  "interface Tunnel0\n"
  " ip address 10.10.10.1 255.255.255.0\n"
  " ip mtu 1416\n"
)
# print(template) - красиво покажет вывод с переводом строк, без лишних пробелов в начале строк

# строке можно обращаться по индексу или делать срез строки
cmd = "interface Gi0/0"
cmd[2]   - >  "t"
cmd[-4]  - >  "i"  
cmd[0:5]  - >  "inter"    # последний символ не включается в срезе
cmd[2:]                   # срезать от 2 до конца
cmd[:7]                   # срезать с 0 до до 7
cmd[-7:]                  # срезать от -7 до конца
# можно в индексах использовать переменные, только числа
# срез с шагом
s = "0123456789"
s[0:9:2]   - >  "02468"
s[1:9:2]   - >  "1357"
s[0:9:3]   - >  "036"
s[::3]     - >  "0369"
s[::2]     - >  "02468"
s[::-1]    - >  "9876543210"  # в обратном порядке
# строки можно складывать, отличается от конкатинации, тем что сами переменные объеденяются а не их литералы
а = "hello"
b = "world"
a + b   - >  "helloworld"
print(a + " " + b)

# строку можно умножать (повторение)   !(строку с числом складывать нельзя)
"test" * 2   - > testtest

# количество символов (длина переменной), спецсимволы тоже считаются
len(cmd)   - >  15

-----------------------------------------------------

МЕТОД - это фунцкия прилепленная к конкретному типу данных

cmd.upper()  - > "INTERFACE GI0/0"   #то есть метод upper сделал заглывные буквы у переменной cmd

cmd.lower?   - > # будет подсказка по методу
cmd.<TAB>    - > все методы покажет

cmd.swapcase()
cmd.capitalize()

cmd.startswith("interface")    -> true     
cmd.endswith("interface")      -> false     
if cmd.startswith("interface"):
    print("OK") 

cmd.startswith(" interface", 1)    -> true, проверить начало строки начиная с индекса 1 (к примеру пропустить пробел)
cmd.startswith(("test", "interface"))    -> строка начинается или с того или с того

cmd.count("e")       # 2 раза, посчитать сколько раз встречается подстрока      
 
cmd.find("face")     # найти подстроку, вернет индекс с которого она начинается, если не найдет то вернет -1

index = cmd.find("face")  # записали в переменную index индекс с которого начинается подсрока face в строке cmd
cmd[index:]               # сделали срез в строке

cmd = " switchport mode access"
find_word = "mode"
index = cmd.find(find_word)
cmd[index:index + len(find_word)]      -> получим слово "mode" сделав срез

cmd.replace("access", "trunk")        # заменить подсроку в строке (заменяет все вхождения)
cmd.replace("o", "test", 1)           # заменить только первое вхождение
cmd.replace("mode", "").replace("trunk", "access vlan 2")   # удалили "mode" и паравозтком еще раз заменили подстроку)

cmd = "\n\n\tinterface Gi0/0\n\t"
cmd.strip()        # удалить все спец. символы в начале и в конце строки
cmd.lstrip()       # удалить все спец. символы в начале строки
cmd.rstrip()       # удалить все спец. символы в конце строки

s = "[110/25]"
s.strip("[]")      #  110/25 , удалили конкретные символы в конце и начале

cmd = " switchport trunk allowed vlan 1,2,3,4,5\n"
cmd.split()        #  удалить спец символы и разделить строку на отдельные элементы строки, потом можно взять последний элемент с вланами
cmd.split()[-2]    # "vlan"

vlan = "1,2,3,4,5"
vlan.split(",")     # разделить на элементы по запятой
ip = "10.1.1.1"
ip.split(".")

-----------------------------------------------------

ФОРМАТИРОВАНИЕ СТРОК

cmd = "interface Gi0/{}"
cmd.format(10)              # interface Gi0/10

template = """ 
  interface Tunnel{}
   ip address {}
   ip mtu 1416
"""
template.format(0, "10.1.1.1 255.255.255.0")    # можно и с replace заменить но это некрасиво и неправльно будет

template = """ 
  interface Tunnel{1}
   ip address {0}
   ip mtu 1416
"""
template.format("10.1.1.1 255.255.255.0", 0)    # можно в формате индексы проставить если не попорядку подставлять значения

template = """ 
  interface Tunnel{tun_num}
   ip address {ip_addr}
   ip mtu 1416
"""
template.format(ip_addr="10.1.1.1 255.255.255.0", tun_num=0)    # можно в формате имена использовать

# С номерами и именами можно несколько раз передавать одно и тоже значение в шаблон, ели потребуется

output = "{} {} {}\n"*2
outpit.format("Fa0/1", "10.1.1.1", "255.255.255.0", "Fa0/15", "10.200.1.1", "255.255.255.0")  # при отображении этих двух строк будет сдвиг

output = "{:10}{:20}{}\n"*2      # выравнивание, задать ширину значения/столбца с запасом, тогда при отображении строк сдвига не будет
output = "{:<10}{:>20}{}\n"*2    # выравнивание < по левой стороне, > по правой стороне

template ="{:b} {:b} {:b} {:b}"            # конвертировать в двоичный формат
template.format(10, 1, 100, 168)
template = "{:08b} {:08b} {:08b} {:08b}"   # перевести в двоичный формат и заполнить нулями до восьми символов (08)
template = "{0:<9}{1:<9}{2:<9}{3:<9}\n{0:08b} {1:08b} {2:08b} {3:08b}"   # вывести адрес в десятичном и двоичном виде и выровнять

# строку можно разбивать на литералы, так как есть ограничения на макс.число символов в строке, и для удобства
s = ('Test' 'String')
s = ('Test'
'String')               # TestString

-----------------------------------------------------

F-СТРОКИ - форматирование строк, нет разделения между шаблоном и данными (в циклах удобнее работать)

intf = "Gi0/0"
f"interface {intf}"       # получим "interface Gi0/0"

cmd = "switchport trunk allowed vlan"
vlan = "1,2,3,4"
f"{cmd} {vlan}"           # получим объединение строк, также как: cmd + " " + vlan
f"{cmd.upper()} {vlan}"   # плюс в том что можно в f-строке можно методы использовать в переменной

oct1, oct2, oct3, oct4 = 10, 1, 100, 168 
template = f"{oct1:<9}{oct2:<9}{oct3:<9}{oct4:<9}\n{oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}"   # тоже самое форматирование через ф-строку (выведет в двоичном и десятичном форате Ip-адрес)

-----------------------------------------------------

# СПИСОК (list) 

# последовательность любых элементов, разделенных запятой в квадратных скобках
# в отличие от строк это изменяемый тип данных

list1 = [10, 20, 77, "word"]        # могут бытьне обязательно однотипные
list2 = [                           # для удобства красоты можно столбиком делать список
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]

vlan = "1, 2, 3, 4"
vlan.split(",")         # ["1", "2", "3", "4"]  получить список строк из строки по разделителю запятой

list("test")            # ["t", "e", "s", "t"]  функция list из строки делает список символов

vlans = [10, 100, 101, 200, 201, 202]
vlans[0]                # 10    первый элемент списка, возвращает число
vlans[3]                # 200   четвертый элемент списка
vlans[-1]               # 202   первый с конда элемент списка
vlans[1:4]              # [100, 101, 200]   сделать срез по списку, возвращает список
vlans[3:]               # [200, 201, 202] 
vlans[:4]               # [10, 100, 101, 200] 

vlans[3] = 1200         # изменить элемент под индексом 3 

СПИСОК СПИСКОВ

vlans = [[10,20,30],[100,200,300],[1000,2000,3000]]
vlans[1]            # [100,200,300]
vlans[1][-1]        # 300
# или
list0 = vlans[1]
list0[-1]            # 300 (через промежуточную переменную)

vlans[1][-1] = 400   # изменить элемент во вложенном списке

# interfaces[0][1][1] - можно список списков разобрать на символы

len(vlans)      # посчитать количество эелементов в списке
sorted(vlans)   # сортировака списка, если есть вложенность, то сортирует списки по первому элементу списка
                # можно по алфавиту сортировать, учитывается регистр, можно в обратном порядке сортировать
                # числа и строки сортируются по разному, если к примеру сортируем vlan то лучше их превратить в числа предварительно
                # строки можно сравнивать (сравнение идет по юникод коду символов по порядку)
set(vlans)      # превратит в множество и удалит дубликаты
# sorted сортирует и превращает в список

МЕТОДЫ РАБОТЫ СО СПИСКАМИ

# функция sorted работает с разными типами данных и возвращает новый список чисел или строк к пимеру
result = sorted(vlans)
print(result)
# метод sotr работает только со списками и сортирует тот же самый список и по умолчанию результат не выводит на print (выводит NONE)
vlans.sort()       # отсортирует список но ничего не выведет (NONE)
print(vlans)       # так выведет на экран

vlans.reverse()    # сделает список наоборот

vlans.count(10)         # посчитать сколько 10 в списке
vlans.append(500)       # добавить в конец списка элемент 500, можно создать пустой список и в него добавлять: vlans = []
                        # добавить можно по одному элементу только
vlans.append([100,200]) # можно в список добавить список, но только один

# суммирование списков
vlans1 = [10,20,30,40]
vlans2 = [100,200,300]
vlans1.extend(vlans2)   # прибавить элементы списка vlans2 в список vlan1
vlans1.extend([5,55])   # тоже добавить в список

all_vlans = vlans1 + vlans2     # второй способ суммирования списков, будет новый список в отличие от extend

# метод join - разделитель, применяется для строк или списка строк (если есть список чисел, то их надо преобразовать в спиcок строк сначала)

vlans_str = ["1", "2", "3"]
",".join(vlans_str)               # '1,2,3'
" = ".join(vlans_str)             # '1 = 2 = 3'

# если есть список строк разделенных например \n, то можно преобразовать в строку с разделителями
access = [
    "switchport mode access",
    "switchport access vlan 20",
    "spanning-tree portfast"
]
"\n".join(access)
print("\n".join(access))   -- >
switchport mode access
switchport access vlan 20
spanning-tree portfast
# можно обратно строку в список перевести
data = "\n".join(access)
data.split("\n")

# взять элемент из списка по индексу и удалить его из списка, только один элемент может удалить, элемент который удаляет можно присвоить переменной
vlans = [10,100,101,200,201,202]
vlans.pop()                         # 202   - по умолчанию удаляет последний элемент
vlans                               # [10,100,101,200,201]
vlans.pop(-1)                       # 201
vlans.pop(0)                        # 10

# remove удаляет значение (только одно), и ничего не возвращает (нельзя записать в переменную) (удалять несколько значений надо через циклы)
vlans.remove(100)                   # удалит из списка элемент со значением 100, если есть несколько элементов, то удалит первый с таким значением
# ниже можно тоже самое сделать через pop, только одной командой
a = vlans[-1]
vlans.remove(a)

vlans.index(201)          # вернет индекс под которым этот элемент

# метод insert вставляет элемент в определенное место в списке
vlans.insert(1, 15)         # вставит число 15 после первого элемента, остальные индексы сместит


# !!! В Python переменные это ссылки (метки) на данные
vlans1 = [1, 2, 3]
vlans2 = vlans1         # vlan2 будет ссылаться на туже область памяти как и vlans1
vlans1.append(100)      # значение 100 добавиться и в список vlans1 в список vlans2  
# убедиться можно посмотря на что ссылаются переменные (на одну и ту же ечейку памяти)
id(vlans1) 
id(vlans2)
# можно делать копии списков, чтобы у списков были разные ячейки памяти
vlans2 =vlans1.copy()
# или через срез создать копию
vlans2 = vlans1[:]

-----------------------------------------------------

# СЛОВАРИ

# 2 вида записи словаря
london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
london = {
    'id': 1,
    'name': 'London',
    'user_vlan': 1010,
    'mngmt_vlan': 99,
    'to_name': None,        # none - нет значения
    'port': 'G1/0/11'
}

# 'name': 'London1'  - ключ: значение,

# доступ к значению по ключу, но по значению ключ найти нельзя (для этого словарь не преднасзначен) (только методом перебора)  
# ключ должен быть неизменяемого типа (число, строка, кортеж), значение может быть любого типа

london["name"]                   # обращение к элементу
value = london["name"]           

london["vendor"] = "Eltex"       # изменить значения для ключа Vendor
london["ip"] = "10.1.1.1"        # добавить в словарь новую пару ключ-значение

# может быть словарь в словаре (очень распространенный вариант)
london_co = {
    'r1': {
        'hostname': 'london_r1',
        'vendor': 'Cisco',
        'model': '4451',
    },
    'r2': {
        'hostname': 'london_r2',
        'vendor': 'Cisco',
        'model': '3925',
    },
}

# модуль pprint используется для красивого отображения сложных словарей
from pprint import pprint
pprint(london_co)

london_co["r2"]["model"]            # --> "3925"  - обращение к подсловарю 
london_co["r2"]["model"] = "7206"   # изменить модель R2

len(london_co)                      # количество ключей
sorted(london_co["r1"])             # отсортировать в словаре r1, сортировка только по ключам работает

del london["name"]                  # удалить ключ name

london.clear()                      # обнулить/очитсить словарь
# или
london = {}

# Копия словаря методом указания что один словарь равен другому означает, что копируются ключи словаря, а значения это ссылки на другой словарь
# лучше копировать методом copy
london2 = london.copy()

# Метод get
london.get("nam")               # если такого ключа нет, то ошибки не будет, а просто вернется None
london.get("nam", "No Key")     # можно вернуть любое свое значения, если такого ключа нет, например No Key
#
"vendor" in london      # узнать если ключ vendor в словаре london (вернет либо True либо false)

london.keys()           # получить все ключи
london.values()         # получить все значения
london.items()          # получить все пары ключ-значение

# keys, values, items - специальные типы данных которые являются ссылками на словари, меняются вместе со словарем
keys = london.keys()              # нельзя потом обратиться к keys[0], но можно сделать следующее
keys = list(london.keys())        # получим список ключей, можно сделать keys[0]
values_1 = list(london.values())  # получим список значений
items = list(london.items())      # получим список пар в виде кортежа

# метод update - можно суммировать/объеденять словари
r1 = {'name': 'London', 'vendor': 'Cisco'}
r1_new = {'ip': '10.1.1.1', 'vendor': 'Eltex'}
r1.update(r1_new)                               # в словарь r1 добавится ключ ip и измениться значение ключа vendor
# или так без промежуточной переменной:
r1.update({'ip': '10.1.1.1', 'vendor': 'Eltex'})

# Метод pop
london.pop("name")                  # взять ключ name и удалить его из словаря
# или можно было сделать так вместо pop:
value = london["name"]
del london["name"]

# Списки подходят под однородные данные, в отличие от словарей
# можно из списков сделать словарь, например
access_1 = ['sw mode accecc', 'sw access vlan 10']
trunk_1 = ['sw mode trunk', 'sw trunk allowed vlan 10,20']
sw_command = {'access': access_1, 'trunk' = trunk_1}        # access_1 и trunk_1 это ссылки на списки, если изменим переменные то и словарь изменится

# !Некоторые методы нельзя делать прямо в значиии в словаре, например 
d = {1: [1,2,3].append(4)}          # вернет None
# надо делать через промежуточные переменные
d = {1: [1,2,3]}
d[1].append(4)

d[1].insert(2,100)      #  d -- > {1: [1, 2, 200, 3, 4]}    вставить илемент в значение списка ключа 1

# вариант создания словаря с DICT если все значения являются строками
r1 = dict(model="4451", ios="15.4")     # конструктор dict позволяет не использовать кавычки в ключах и скобки
# еще вариат с dict если есть список кортежей
r1 = dict([('model', '4451'), ('ios', '15.4')])

# dict.fromkeys()   - сделать заготовку словаря, если знаешь ключи но нет значений еще, чтобы в него потом к примеру записывать
d_keys = ['hostname', 'vendor', 'ip']
r1 = dict.fromkeys(d_keys)              #  r1 -->  {'hostname': None 'vendor': None, 'ip': None}

# Пример, создать словарь который будет подсчитывать кол-во Vlan на коммутаторах, 
sw1_vlans = [1, 2, 3, 4]                    # список vlan на sw1
sw2_vlans = [1, 3, 4]                       # список vlan на sw2
hostnames = ['sw1', 'sw2']                  # создаем список коммутаторов
all_vlans = dict.fromkeys(hostnames, 0)     # создали словарь с дефолтным значениями 0, -> {'sw1': 0, 'sw2': 0}  - 
all_vlans['sw1'] += len(sw1_vlans)          # записываем в словарь количество vlan на sw1   ( +=  значит   all_vlans['sw1'] = all_vlans['sw1']) + len(sw1_vlans)
all_vlans['sw2'] += len(sw2_vlans)          # записываем в словарь количество vlan на sw2
print(all_vlans)                            # {'sw1': 4, 'sw2': 3}

-----------------------------------------------------

# КОРТЕЖ (tuple)

# Это можно сказать неизменяемый упорядоченный список, вместо [] используется ()
# Кортеж дает возможность в ключах словаря писать несколько элементов (так как список в ключах словаря использовать нельзя)
# Также используется когда данные мы получаем извне (например: из БД, из csv-файла)

data = ('sw1', '10.1.1.1', 'Cisco IOS')
data.count('sw1')                   # 1
data.index('Cisco IOS')             # 2

tuple1 = tuple()                    # пустой кортеж (очень редко, но бывает нужен), обязательно tuple надо указать для пустого кортежа
tuple2 = ('password',)              # кортеж из одного элемента (иногда нужен), обязательно запятая в конце

# Кортеж из списка, tuple - превратить в кортеж
list_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']
tuple_keys = tuple(list_keys)       # ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

tuple_keys[0]                       # 'hostname'
tuple_keys[1:]                      # ('location', 'vendor', 'model', 'ios', 'ip')  - срез

tuple('test')                       # ('t', 'e', 's', 't')                       

# добвить элемент в кортеж
vlans = (1,2,3)
vlans_new = vlans + (4,) + (5,6)    # (1,2,3,4,5,6)

# сортировка
sorted(tuple_keys)                  # сортирует и возвращает список 

-----------------------------------------------------

# МНОЖЕСТВО (set)

# Это изменяемый неупорядоченный тип данных, содержатся только уникальные элементы
# используются фигурные скобки, но в отличие от словаря нет пары ключ-значение

vlans = {10,20,30,10,20,1}       # {1,10,20,30}   - уникальные элементы, но необязательно по порядку
names = {'sw1', 'sw2', 'rt1'}

# пример есть список, надо получить список уникальных элементов из него
vlans = [1,2,3,4,3,1,2,1]
list(set(vlans))                # [1,2,3,4]  

set1.add(5)                    # добавить элемент в множество
set1.remove(4)                 # удалить элемент из множества
set1.update([50,60])           # добавить несколько элементов

# операции с множеством
vlans1 = {1,2,3,4,5}
vlans2 = {3,4,5,6,7}
vlans1.intersection(vlans2)    # {3,4,5} - какие vlan общие
vlans1.difference(vlans2)      # {1,2} - какие vlan есть в множестве vlans1 но нет в vlans2
vlans1.union(vlans2)           # {1,2,3,4,5,6,7} - объединение множеств
vlans1 & vlans2                # тоже самое что intersection
vlans1 - vlans2                # тоже самое что difference
vlans1 | vlans2                # тоже самое что union
vlans1.symmetric_difference(vlans2)     # {1,2,6,7} - что уникального в обоих множествах 

set1 = {}       # это будет пустой словарь
set1 = set{}    # это будет пустое множество, так создается со словом set

-----------------------------------------------------

# БУЛЕВЫ ЗНАЧЕНИЯ (Boolean)


None
True
False
# регистр имеет значение, если с маленькой буквы то уже будет переменные

s = 'hello'
s.startswith('h')       # True

vlans = [1,2,3,4]
5 in vlans              # False

# Ложные значения:
0
None
пустая строка
пустой объект
# Остальные истинные значения 

# bool - проверяет истинное значение или ложное
bool(vlans)         # True
bool(2)             # True
bool([])            # False
bool(0)             # False

if vlans:              # если не равно 0
# или тоже самое
if len(vlans) != 0:

-----------------------------------------------------

#### ПРЕОБРАЗОВНИЕ ТИПОВ ###

int()    # преобразование строки в число
bin()    # дяситичное число в двоичное
hex()    # дяситичное число в 16-ричное
list()   # преобразует аргумент в список 
set()    # преобразует аргумент в множество уникальных элементов
tuple()  # преобразует аргумент в кортеж
str()    # преобразует аргумент в строку

### ПРОВЕРКА ТИПОВ ###

# есть куча методов для строк is...
isdigit()         # проверить состоит ли строка из одних цифр
isalpha()         # проверить состоит ли строка из одних букв
"a10".isdigit()   # False    (если будет True то можно будет строку к примеру в число превратить)  
"abc".isalpha()   # True

type()                     # функция проверяет тип перменной
type(aaa)                  # Если aaa - строка, то вернет str, если aaa - список то вернет list и т.д
if type('aaa') == str:     # потом применяем в условии

-----------------------------------------------------

### СОЗДАНИЕ БАЗОВЫХ СКРИПТОВ ###

Чтобы сделатьфайл исполняемым в linux надо в первой строке написать
#!/usr/bin/env python
либо
#!/usr/bin/env python3

# после этого дать права на запуск файла
chmod +x access_template_exec.py

# и запускать след. образом
./access_template_exec.py


### Передача аргументов скрипту с помощью argv ### 

# первый способ
import sys
vlan = sys.argv[1]   # говорим что Vlan получить из аргумента с индексом 1, (индекс 0 - это всегда имя скрипта)

print(sys.argv)      # напечать аргументы, которые мы передаем в скрипт при запуске скрипта
 
# второй способ
from sys import argv
vlan = argv[1]

python access_template_argv.py 5       #  запуск скрипта

# в argv все передается как строки, если нужно передать как число то надо конвертировать int

### Передача аргументов с помощью input

# Функция input - передать информацию скрипту по запросу, аргументы передаются в input тоже как строки

vlan = input("Введи номер Vlan: ")
intf = input("Введи номер интерфейса: ")

input("Нажмите Enter для продолжения")     # сделать паузу в скрипте







































